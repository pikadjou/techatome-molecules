import { NgIf } from '@angular/common';
import { Component, Input } from '@angular/core';
import { TranslateModule } from '@ngx-translate/core';
import { FontIconComponent, LocalIconComponent } from '@ta/icons';
import { getFontIcon, isFontIcon, isLocalIcon } from '@ta/icons';
import { CamTranslationUI } from '../translation.service';
import { TypedMessageComponent } from '../typed-message/typed-message.component';
import * as i0 from "@angular/core";
import * as i1 from "@ngx-translate/core";
export class PictureInfoMessageComponent {
    get displayedText() {
        return this.text ?? '';
    }
    isFontIcon(icon) {
        return isFontIcon(icon);
    }
    getFontIcon(icon) {
        return getFontIcon(icon);
    }
    isLocalIcon(icon) {
        return isLocalIcon(icon);
    }
    constructor() {
        this.type = 'info';
        CamTranslationUI.getInstance();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: PictureInfoMessageComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "18.2.13", type: PictureInfoMessageComponent, isStandalone: true, selector: "ta-picture-info-message", inputs: { icon: "icon", iconSize: "iconSize", text: "text", type: "type" }, ngImport: i0, template: "@if (this.icon) {\n  <div class=\"card\">\n    @if (this.isLocalIcon(this.icon)) {\n      <ta-local-icon\n        [type]=\"this.icon\"\n        [size]=\"this.iconSize ?? 'md'\"\n      ></ta-local-icon>\n    } @else if (this.isFontIcon(this.icon)) {\n      <ta-font-icon\n        class=\"font-icon\"\n        [name]=\"this.getFontIcon(this.icon)\"\n        [type]=\"this.iconSize ?? 'md'\"\n      ></ta-font-icon>\n    }\n\n    <div class=\"pt-space-xs\">{{ this.displayedText | translate }}</div>\n  </div>\n} @else {\n  <ta-typed-message [text]=\"this.displayedText\" [type]=\"this.type ?? 'info'\"></ta-typed-message>\n}\n", styles: [".card{padding:var(--ta-space-sm);text-align:center}p{padding-top:var(--ta-space-sm)}ta-font-icon{color:var(--ta-brand-400)}\n"], dependencies: [{ kind: "component", type: FontIconComponent, selector: "ta-font-icon", inputs: ["name", "type"] }, { kind: "component", type: LocalIconComponent, selector: "ta-local-icon", inputs: ["type", "size", "rotation"] }, { kind: "ngmodule", type: TranslateModule }, { kind: "pipe", type: i1.TranslatePipe, name: "translate" }, { kind: "component", type: TypedMessageComponent, selector: "ta-typed-message", inputs: ["text", "type"] }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: PictureInfoMessageComponent, decorators: [{
            type: Component,
            args: [{ selector: 'ta-picture-info-message', standalone: true, imports: [NgIf, FontIconComponent, LocalIconComponent, TranslateModule, TypedMessageComponent], template: "@if (this.icon) {\n  <div class=\"card\">\n    @if (this.isLocalIcon(this.icon)) {\n      <ta-local-icon\n        [type]=\"this.icon\"\n        [size]=\"this.iconSize ?? 'md'\"\n      ></ta-local-icon>\n    } @else if (this.isFontIcon(this.icon)) {\n      <ta-font-icon\n        class=\"font-icon\"\n        [name]=\"this.getFontIcon(this.icon)\"\n        [type]=\"this.iconSize ?? 'md'\"\n      ></ta-font-icon>\n    }\n\n    <div class=\"pt-space-xs\">{{ this.displayedText | translate }}</div>\n  </div>\n} @else {\n  <ta-typed-message [text]=\"this.displayedText\" [type]=\"this.type ?? 'info'\"></ta-typed-message>\n}\n", styles: [".card{padding:var(--ta-space-sm);text-align:center}p{padding-top:var(--ta-space-sm)}ta-font-icon{color:var(--ta-brand-400)}\n"] }]
        }], ctorParameters: () => [], propDecorators: { icon: [{
                type: Input
            }], iconSize: [{
                type: Input
            }], text: [{
                type: Input
            }], type: [{
                type: Input
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGljdHVyZS1pbmZvLW1lc3NhZ2UuY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vc3JjL2xpYi9jb21wb25lbnRzL3VpL3BpY3R1cmUtaW5mby1tZXNzYWdlL3BpY3R1cmUtaW5mby1tZXNzYWdlLmNvbXBvbmVudC50cyIsIi4uLy4uLy4uLy4uLy4uLy4uL3NyYy9saWIvY29tcG9uZW50cy91aS9waWN0dXJlLWluZm8tbWVzc2FnZS9waWN0dXJlLWluZm8tbWVzc2FnZS5jb21wb25lbnQuaHRtbCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsSUFBSSxFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFDdkMsT0FBTyxFQUFFLFNBQVMsRUFBRSxLQUFLLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFFakQsT0FBTyxFQUFFLGVBQWUsRUFBRSxNQUFNLHFCQUFxQixDQUFDO0FBQ3RELE9BQU8sRUFBRSxpQkFBaUIsRUFBRSxrQkFBa0IsRUFBRSxNQUFNLFdBQVcsQ0FBQztBQUNsRSxPQUFPLEVBQUUsV0FBVyxFQUFFLFVBQVUsRUFBRSxXQUFXLEVBQUUsTUFBTSxXQUFXLENBQUM7QUFLakUsT0FBTyxFQUFFLGdCQUFnQixFQUFFLE1BQU0sd0JBQXdCLENBQUM7QUFDMUQsT0FBTyxFQUFFLHFCQUFxQixFQUFFLE1BQU0sMENBQTBDLENBQUM7OztBQVNqRixNQUFNLE9BQU8sMkJBQTJCO0lBTXRDLElBQUksYUFBYTtRQUNmLE9BQU8sSUFBSSxDQUFDLElBQUksSUFBSSxFQUFFLENBQUM7SUFDekIsQ0FBQztJQUVNLFVBQVUsQ0FBQyxJQUEwQjtRQUMxQyxPQUFPLFVBQVUsQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUMxQixDQUFDO0lBRU0sV0FBVyxDQUFDLElBQTBCO1FBQzNDLE9BQU8sV0FBVyxDQUFDLElBQUksQ0FBQyxDQUFDO0lBQzNCLENBQUM7SUFFTSxXQUFXLENBQUMsSUFBMEI7UUFDM0MsT0FBTyxXQUFXLENBQUMsSUFBSSxDQUFDLENBQUM7SUFDM0IsQ0FBQztJQUVEO1FBbEJTLFNBQUksR0FBa0IsTUFBTSxDQUFDO1FBbUJwQyxnQkFBZ0IsQ0FBQyxXQUFXLEVBQUUsQ0FBQztJQUNqQyxDQUFDOytHQXhCVSwyQkFBMkI7bUdBQTNCLDJCQUEyQiwrSkNwQnhDLGtuQkFvQkEsdUxERmtCLGlCQUFpQixtRkFBRSxrQkFBa0IsK0ZBQUUsZUFBZSw0RkFBRSxxQkFBcUI7OzRGQUVsRiwyQkFBMkI7a0JBUHZDLFNBQVM7K0JBQ0UseUJBQXlCLGNBR3ZCLElBQUksV0FDUCxDQUFDLElBQUksRUFBRSxpQkFBaUIsRUFBRSxrQkFBa0IsRUFBRSxlQUFlLEVBQUUscUJBQXFCLENBQUM7d0RBR3JGLElBQUk7c0JBQVosS0FBSztnQkFDRyxRQUFRO3NCQUFoQixLQUFLO2dCQUNHLElBQUk7c0JBQVosS0FBSztnQkFDRyxJQUFJO3NCQUFaLEtBQUsiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBOZ0lmIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7IENvbXBvbmVudCwgSW5wdXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHsgVHJhbnNsYXRlTW9kdWxlIH0gZnJvbSAnQG5neC10cmFuc2xhdGUvY29yZSc7XG5pbXBvcnQgeyBGb250SWNvbkNvbXBvbmVudCwgTG9jYWxJY29uQ29tcG9uZW50IH0gZnJvbSAnQHRhL2ljb25zJztcbmltcG9ydCB7IGdldEZvbnRJY29uLCBpc0ZvbnRJY29uLCBpc0xvY2FsSWNvbiB9IGZyb20gJ0B0YS9pY29ucyc7XG5pbXBvcnQgeyBDYW1JY29uVHlwZSB9IGZyb20gJ0B0YS9pY29ucyc7XG5pbXBvcnQgeyBUYVNpemVzIH0gZnJvbSAnQHRhL3N0eWxlcyc7XG5pbXBvcnQgeyBNZXNzYWdlTGV2ZWwgfSBmcm9tICdAdGEvdXRpbHMnO1xuXG5pbXBvcnQgeyBDYW1UcmFuc2xhdGlvblVJIH0gZnJvbSAnLi4vdHJhbnNsYXRpb24uc2VydmljZSc7XG5pbXBvcnQgeyBUeXBlZE1lc3NhZ2VDb21wb25lbnQgfSBmcm9tICcuLi90eXBlZC1tZXNzYWdlL3R5cGVkLW1lc3NhZ2UuY29tcG9uZW50JztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAndGEtcGljdHVyZS1pbmZvLW1lc3NhZ2UnLFxuICB0ZW1wbGF0ZVVybDogJy4vcGljdHVyZS1pbmZvLW1lc3NhZ2UuY29tcG9uZW50Lmh0bWwnLFxuICBzdHlsZVVybHM6IFsnLi9waWN0dXJlLWluZm8tbWVzc2FnZS5jb21wb25lbnQuc2NzcyddLFxuICBzdGFuZGFsb25lOiB0cnVlLFxuICBpbXBvcnRzOiBbTmdJZiwgRm9udEljb25Db21wb25lbnQsIExvY2FsSWNvbkNvbXBvbmVudCwgVHJhbnNsYXRlTW9kdWxlLCBUeXBlZE1lc3NhZ2VDb21wb25lbnRdLFxufSlcbmV4cG9ydCBjbGFzcyBQaWN0dXJlSW5mb01lc3NhZ2VDb21wb25lbnQge1xuICBASW5wdXQoKSBpY29uPzogQ2FtSWNvblR5cGUgfCBzdHJpbmc7XG4gIEBJbnB1dCgpIGljb25TaXplPzogVGFTaXplcyB8ICd4bCc7XG4gIEBJbnB1dCgpIHRleHQ/OiBzdHJpbmc7XG4gIEBJbnB1dCgpIHR5cGU/OiBNZXNzYWdlTGV2ZWwgPSAnaW5mbyc7XG5cbiAgZ2V0IGRpc3BsYXllZFRleHQoKSB7XG4gICAgcmV0dXJuIHRoaXMudGV4dCA/PyAnJztcbiAgfVxuXG4gIHB1YmxpYyBpc0ZvbnRJY29uKGljb246IENhbUljb25UeXBlIHwgc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIGlzRm9udEljb24oaWNvbik7XG4gIH1cblxuICBwdWJsaWMgZ2V0Rm9udEljb24oaWNvbjogQ2FtSWNvblR5cGUgfCBzdHJpbmcpOiBzdHJpbmcge1xuICAgIHJldHVybiBnZXRGb250SWNvbihpY29uKTtcbiAgfVxuXG4gIHB1YmxpYyBpc0xvY2FsSWNvbihpY29uOiBDYW1JY29uVHlwZSB8IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBpc0xvY2FsSWNvbihpY29uKTtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIENhbVRyYW5zbGF0aW9uVUkuZ2V0SW5zdGFuY2UoKTtcbiAgfVxufVxuIiwiQGlmICh0aGlzLmljb24pIHtcbiAgPGRpdiBjbGFzcz1cImNhcmRcIj5cbiAgICBAaWYgKHRoaXMuaXNMb2NhbEljb24odGhpcy5pY29uKSkge1xuICAgICAgPHRhLWxvY2FsLWljb25cbiAgICAgICAgW3R5cGVdPVwidGhpcy5pY29uXCJcbiAgICAgICAgW3NpemVdPVwidGhpcy5pY29uU2l6ZSA/PyAnbWQnXCJcbiAgICAgID48L3RhLWxvY2FsLWljb24+XG4gICAgfSBAZWxzZSBpZiAodGhpcy5pc0ZvbnRJY29uKHRoaXMuaWNvbikpIHtcbiAgICAgIDx0YS1mb250LWljb25cbiAgICAgICAgY2xhc3M9XCJmb250LWljb25cIlxuICAgICAgICBbbmFtZV09XCJ0aGlzLmdldEZvbnRJY29uKHRoaXMuaWNvbilcIlxuICAgICAgICBbdHlwZV09XCJ0aGlzLmljb25TaXplID8/ICdtZCdcIlxuICAgICAgPjwvdGEtZm9udC1pY29uPlxuICAgIH1cblxuICAgIDxkaXYgY2xhc3M9XCJwdC1zcGFjZS14c1wiPnt7IHRoaXMuZGlzcGxheWVkVGV4dCB8IHRyYW5zbGF0ZSB9fTwvZGl2PlxuICA8L2Rpdj5cbn0gQGVsc2Uge1xuICA8dGEtdHlwZWQtbWVzc2FnZSBbdGV4dF09XCJ0aGlzLmRpc3BsYXllZFRleHRcIiBbdHlwZV09XCJ0aGlzLnR5cGUgPz8gJ2luZm8nXCI+PC90YS10eXBlZC1tZXNzYWdlPlxufVxuIl19