import { NgIf } from '@angular/common';
import { Component, Input } from '@angular/core';
import { TranslateModule } from '@ngx-translate/core';
import { FontIconComponent, LocalIconComponent } from '@ta/icons';
import { getFontIcon, isFontIcon, isLocalIcon } from '@ta/icons';
import { TaTranslationUI } from '../translation.service';
import { TypedMessageComponent } from '../typed-message/typed-message.component';
import * as i0 from "@angular/core";
import * as i1 from "@ngx-translate/core";
export class PictureInfoMessageComponent {
    get displayedText() {
        return this.text ?? '';
    }
    isFontIcon(icon) {
        return isFontIcon(icon);
    }
    getFontIcon(icon) {
        return getFontIcon(icon);
    }
    isLocalIcon(icon) {
        return isLocalIcon(icon);
    }
    constructor() {
        this.type = 'info';
        TaTranslationUI.getInstance();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.14", ngImport: i0, type: PictureInfoMessageComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "18.2.14", type: PictureInfoMessageComponent, isStandalone: true, selector: "ta-picture-info-message", inputs: { icon: "icon", iconSize: "iconSize", text: "text", type: "type" }, ngImport: i0, template: "@if (this.icon) {\n  <div class=\"card\">\n    @if (this.isLocalIcon(this.icon)) {\n      <ta-local-icon\n        [type]=\"this.icon\"\n        [size]=\"this.iconSize ?? 'md'\"\n      ></ta-local-icon>\n    } @else if (this.isFontIcon(this.icon)) {\n      <ta-font-icon\n        class=\"font-icon\"\n        [name]=\"this.getFontIcon(this.icon)\"\n        [type]=\"this.iconSize ?? 'md'\"\n      ></ta-font-icon>\n    }\n\n    <div class=\"pt-space-xs\">{{ this.displayedText | translate }}</div>\n  </div>\n} @else {\n  <ta-typed-message [text]=\"this.displayedText\" [type]=\"this.type ?? 'info'\"></ta-typed-message>\n}\n", styles: [".card{padding:var(--ta-space-sm);text-align:center}p{padding-top:var(--ta-space-sm)}ta-font-icon{color:var(--ta-brand-400)}\n"], dependencies: [{ kind: "component", type: FontIconComponent, selector: "ta-font-icon", inputs: ["name", "type"] }, { kind: "component", type: LocalIconComponent, selector: "ta-local-icon", inputs: ["type", "size", "rotation"] }, { kind: "ngmodule", type: TranslateModule }, { kind: "pipe", type: i1.TranslatePipe, name: "translate" }, { kind: "component", type: TypedMessageComponent, selector: "ta-typed-message", inputs: ["text", "type"] }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.14", ngImport: i0, type: PictureInfoMessageComponent, decorators: [{
            type: Component,
            args: [{ selector: 'ta-picture-info-message', standalone: true, imports: [NgIf, FontIconComponent, LocalIconComponent, TranslateModule, TypedMessageComponent], template: "@if (this.icon) {\n  <div class=\"card\">\n    @if (this.isLocalIcon(this.icon)) {\n      <ta-local-icon\n        [type]=\"this.icon\"\n        [size]=\"this.iconSize ?? 'md'\"\n      ></ta-local-icon>\n    } @else if (this.isFontIcon(this.icon)) {\n      <ta-font-icon\n        class=\"font-icon\"\n        [name]=\"this.getFontIcon(this.icon)\"\n        [type]=\"this.iconSize ?? 'md'\"\n      ></ta-font-icon>\n    }\n\n    <div class=\"pt-space-xs\">{{ this.displayedText | translate }}</div>\n  </div>\n} @else {\n  <ta-typed-message [text]=\"this.displayedText\" [type]=\"this.type ?? 'info'\"></ta-typed-message>\n}\n", styles: [".card{padding:var(--ta-space-sm);text-align:center}p{padding-top:var(--ta-space-sm)}ta-font-icon{color:var(--ta-brand-400)}\n"] }]
        }], ctorParameters: () => [], propDecorators: { icon: [{
                type: Input
            }], iconSize: [{
                type: Input
            }], text: [{
                type: Input
            }], type: [{
                type: Input
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGljdHVyZS1pbmZvLW1lc3NhZ2UuY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vc3JjL2xpYi9jb21wb25lbnRzL3VpL3BpY3R1cmUtaW5mby1tZXNzYWdlL3BpY3R1cmUtaW5mby1tZXNzYWdlLmNvbXBvbmVudC50cyIsIi4uLy4uLy4uLy4uLy4uLy4uL3NyYy9saWIvY29tcG9uZW50cy91aS9waWN0dXJlLWluZm8tbWVzc2FnZS9waWN0dXJlLWluZm8tbWVzc2FnZS5jb21wb25lbnQuaHRtbCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsSUFBSSxFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFDdkMsT0FBTyxFQUFFLFNBQVMsRUFBRSxLQUFLLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFFakQsT0FBTyxFQUFFLGVBQWUsRUFBRSxNQUFNLHFCQUFxQixDQUFDO0FBRXRELE9BQU8sRUFBRSxpQkFBaUIsRUFBRSxrQkFBa0IsRUFBRSxNQUFNLFdBQVcsQ0FBQztBQUNsRSxPQUFPLEVBQUUsV0FBVyxFQUFFLFVBQVUsRUFBRSxXQUFXLEVBQUUsTUFBTSxXQUFXLENBQUM7QUFLakUsT0FBTyxFQUFFLGVBQWUsRUFBRSxNQUFNLHdCQUF3QixDQUFDO0FBQ3pELE9BQU8sRUFBRSxxQkFBcUIsRUFBRSxNQUFNLDBDQUEwQyxDQUFDOzs7QUFTakYsTUFBTSxPQUFPLDJCQUEyQjtJQU10QyxJQUFJLGFBQWE7UUFDZixPQUFPLElBQUksQ0FBQyxJQUFJLElBQUksRUFBRSxDQUFDO0lBQ3pCLENBQUM7SUFFTSxVQUFVLENBQUMsSUFBeUI7UUFDekMsT0FBTyxVQUFVLENBQUMsSUFBSSxDQUFDLENBQUM7SUFDMUIsQ0FBQztJQUVNLFdBQVcsQ0FBQyxJQUF5QjtRQUMxQyxPQUFPLFdBQVcsQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUMzQixDQUFDO0lBRU0sV0FBVyxDQUFDLElBQXlCO1FBQzFDLE9BQU8sV0FBVyxDQUFDLElBQUksQ0FBQyxDQUFDO0lBQzNCLENBQUM7SUFFRDtRQWxCUyxTQUFJLEdBQWtCLE1BQU0sQ0FBQztRQW1CcEMsZUFBZSxDQUFDLFdBQVcsRUFBRSxDQUFDO0lBQ2hDLENBQUM7K0dBeEJVLDJCQUEyQjttR0FBM0IsMkJBQTJCLCtKQ3JCeEMsa25CQW9CQSx1TEREa0IsaUJBQWlCLG1GQUFFLGtCQUFrQiwrRkFBRSxlQUFlLDRGQUFFLHFCQUFxQjs7NEZBRWxGLDJCQUEyQjtrQkFQdkMsU0FBUzsrQkFDRSx5QkFBeUIsY0FHdkIsSUFBSSxXQUNQLENBQUMsSUFBSSxFQUFFLGlCQUFpQixFQUFFLGtCQUFrQixFQUFFLGVBQWUsRUFBRSxxQkFBcUIsQ0FBQzt3REFHckYsSUFBSTtzQkFBWixLQUFLO2dCQUNHLFFBQVE7c0JBQWhCLEtBQUs7Z0JBQ0csSUFBSTtzQkFBWixLQUFLO2dCQUNHLElBQUk7c0JBQVosS0FBSyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE5nSWYgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgQ29tcG9uZW50LCBJbnB1dCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBUcmFuc2xhdGVNb2R1bGUgfSBmcm9tICdAbmd4LXRyYW5zbGF0ZS9jb3JlJztcblxuaW1wb3J0IHsgRm9udEljb25Db21wb25lbnQsIExvY2FsSWNvbkNvbXBvbmVudCB9IGZyb20gJ0B0YS9pY29ucyc7XG5pbXBvcnQgeyBnZXRGb250SWNvbiwgaXNGb250SWNvbiwgaXNMb2NhbEljb24gfSBmcm9tICdAdGEvaWNvbnMnO1xuaW1wb3J0IHsgVGFJY29uVHlwZSB9IGZyb20gJ0B0YS9pY29ucyc7XG5pbXBvcnQgeyBUYVNpemVzIH0gZnJvbSAnQHRhL3N0eWxlcyc7XG5pbXBvcnQgeyBNZXNzYWdlTGV2ZWwgfSBmcm9tICdAdGEvdXRpbHMnO1xuXG5pbXBvcnQgeyBUYVRyYW5zbGF0aW9uVUkgfSBmcm9tICcuLi90cmFuc2xhdGlvbi5zZXJ2aWNlJztcbmltcG9ydCB7IFR5cGVkTWVzc2FnZUNvbXBvbmVudCB9IGZyb20gJy4uL3R5cGVkLW1lc3NhZ2UvdHlwZWQtbWVzc2FnZS5jb21wb25lbnQnO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICd0YS1waWN0dXJlLWluZm8tbWVzc2FnZScsXG4gIHRlbXBsYXRlVXJsOiAnLi9waWN0dXJlLWluZm8tbWVzc2FnZS5jb21wb25lbnQuaHRtbCcsXG4gIHN0eWxlVXJsczogWycuL3BpY3R1cmUtaW5mby1tZXNzYWdlLmNvbXBvbmVudC5zY3NzJ10sXG4gIHN0YW5kYWxvbmU6IHRydWUsXG4gIGltcG9ydHM6IFtOZ0lmLCBGb250SWNvbkNvbXBvbmVudCwgTG9jYWxJY29uQ29tcG9uZW50LCBUcmFuc2xhdGVNb2R1bGUsIFR5cGVkTWVzc2FnZUNvbXBvbmVudF0sXG59KVxuZXhwb3J0IGNsYXNzIFBpY3R1cmVJbmZvTWVzc2FnZUNvbXBvbmVudCB7XG4gIEBJbnB1dCgpIGljb24/OiBUYUljb25UeXBlIHwgc3RyaW5nO1xuICBASW5wdXQoKSBpY29uU2l6ZT86IFRhU2l6ZXMgfCAneGwnO1xuICBASW5wdXQoKSB0ZXh0Pzogc3RyaW5nO1xuICBASW5wdXQoKSB0eXBlPzogTWVzc2FnZUxldmVsID0gJ2luZm8nO1xuXG4gIGdldCBkaXNwbGF5ZWRUZXh0KCkge1xuICAgIHJldHVybiB0aGlzLnRleHQgPz8gJyc7XG4gIH1cblxuICBwdWJsaWMgaXNGb250SWNvbihpY29uOiBUYUljb25UeXBlIHwgc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIGlzRm9udEljb24oaWNvbik7XG4gIH1cblxuICBwdWJsaWMgZ2V0Rm9udEljb24oaWNvbjogVGFJY29uVHlwZSB8IHN0cmluZyk6IHN0cmluZyB7XG4gICAgcmV0dXJuIGdldEZvbnRJY29uKGljb24pO1xuICB9XG5cbiAgcHVibGljIGlzTG9jYWxJY29uKGljb246IFRhSWNvblR5cGUgfCBzdHJpbmcpOiBib29sZWFuIHtcbiAgICByZXR1cm4gaXNMb2NhbEljb24oaWNvbik7XG4gIH1cblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBUYVRyYW5zbGF0aW9uVUkuZ2V0SW5zdGFuY2UoKTtcbiAgfVxufVxuIiwiQGlmICh0aGlzLmljb24pIHtcbiAgPGRpdiBjbGFzcz1cImNhcmRcIj5cbiAgICBAaWYgKHRoaXMuaXNMb2NhbEljb24odGhpcy5pY29uKSkge1xuICAgICAgPHRhLWxvY2FsLWljb25cbiAgICAgICAgW3R5cGVdPVwidGhpcy5pY29uXCJcbiAgICAgICAgW3NpemVdPVwidGhpcy5pY29uU2l6ZSA/PyAnbWQnXCJcbiAgICAgID48L3RhLWxvY2FsLWljb24+XG4gICAgfSBAZWxzZSBpZiAodGhpcy5pc0ZvbnRJY29uKHRoaXMuaWNvbikpIHtcbiAgICAgIDx0YS1mb250LWljb25cbiAgICAgICAgY2xhc3M9XCJmb250LWljb25cIlxuICAgICAgICBbbmFtZV09XCJ0aGlzLmdldEZvbnRJY29uKHRoaXMuaWNvbilcIlxuICAgICAgICBbdHlwZV09XCJ0aGlzLmljb25TaXplID8/ICdtZCdcIlxuICAgICAgPjwvdGEtZm9udC1pY29uPlxuICAgIH1cblxuICAgIDxkaXYgY2xhc3M9XCJwdC1zcGFjZS14c1wiPnt7IHRoaXMuZGlzcGxheWVkVGV4dCB8IHRyYW5zbGF0ZSB9fTwvZGl2PlxuICA8L2Rpdj5cbn0gQGVsc2Uge1xuICA8dGEtdHlwZWQtbWVzc2FnZSBbdGV4dF09XCJ0aGlzLmRpc3BsYXllZFRleHRcIiBbdHlwZV09XCJ0aGlzLnR5cGUgPz8gJ2luZm8nXCI+PC90YS10eXBlZC1tZXNzYWdlPlxufVxuIl19