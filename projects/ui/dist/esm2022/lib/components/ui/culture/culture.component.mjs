import { NgFor } from "@angular/common";
import { Component, input } from "@angular/core";
import { TranslateModule } from "@ngx-translate/core";
import { TaTranslationUI } from "../../../translation.service";
import * as i0 from "@angular/core";
import * as i1 from "@ngx-translate/core";
export class CultureComponent {
    constructor() {
        this.cultures = input.required();
        TaTranslationUI.getInstance();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.14", ngImport: i0, type: CultureComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "18.2.14", type: CultureComponent, isStandalone: true, selector: "ta-culture", inputs: { cultures: { classPropertyName: "cultures", publicName: "cultures", isSignal: true, isRequired: true, transformFunction: null } }, ngImport: i0, template: "<div class=\"flex-start g-space-xs\">\n  @for (culture of this.cultures(); track culture; let isLast = $last) {\n  <div>\n    {{ \"ui.culture.short.\" + culture | translate }}{{ !isLast ? \",\" : \"\" }}\n  </div>\n  }\n</div>\n", styles: [""], dependencies: [{ kind: "ngmodule", type: TranslateModule }, { kind: "pipe", type: i1.TranslatePipe, name: "translate" }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.14", ngImport: i0, type: CultureComponent, decorators: [{
            type: Component,
            args: [{ selector: "ta-culture", standalone: true, imports: [NgFor, TranslateModule], template: "<div class=\"flex-start g-space-xs\">\n  @for (culture of this.cultures(); track culture; let isLast = $last) {\n  <div>\n    {{ \"ui.culture.short.\" + culture | translate }}{{ !isLast ? \",\" : \"\" }}\n  </div>\n  }\n</div>\n" }]
        }], ctorParameters: () => [] });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY3VsdHVyZS5jb21wb25lbnQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi9zcmMvbGliL2NvbXBvbmVudHMvdWkvY3VsdHVyZS9jdWx0dXJlLmNvbXBvbmVudC50cyIsIi4uLy4uLy4uLy4uLy4uLy4uL3NyYy9saWIvY29tcG9uZW50cy91aS9jdWx0dXJlL2N1bHR1cmUuY29tcG9uZW50Lmh0bWwiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLEtBQUssRUFBRSxNQUFNLGlCQUFpQixDQUFDO0FBQ3hDLE9BQU8sRUFBRSxTQUFTLEVBQUUsS0FBSyxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBRWpELE9BQU8sRUFBRSxlQUFlLEVBQUUsTUFBTSxxQkFBcUIsQ0FBQztBQUl0RCxPQUFPLEVBQUUsZUFBZSxFQUFFLE1BQU0sOEJBQThCLENBQUM7OztBQVMvRCxNQUFNLE9BQU8sZ0JBQWdCO0lBRzNCO1FBRkEsYUFBUSxHQUFHLEtBQUssQ0FBQyxRQUFRLEVBQWEsQ0FBQztRQUdyQyxlQUFlLENBQUMsV0FBVyxFQUFFLENBQUM7SUFDaEMsQ0FBQzsrR0FMVSxnQkFBZ0I7bUdBQWhCLGdCQUFnQixrTkNoQjdCLHNPQU9BLHlERE9tQixlQUFlOzs0RkFFckIsZ0JBQWdCO2tCQVA1QixTQUFTOytCQUNFLFlBQVksY0FHVixJQUFJLFdBQ1AsQ0FBQyxLQUFLLEVBQUUsZUFBZSxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTmdGb3IgfSBmcm9tIFwiQGFuZ3VsYXIvY29tbW9uXCI7XG5pbXBvcnQgeyBDb21wb25lbnQsIGlucHV0IH0gZnJvbSBcIkBhbmd1bGFyL2NvcmVcIjtcblxuaW1wb3J0IHsgVHJhbnNsYXRlTW9kdWxlIH0gZnJvbSBcIkBuZ3gtdHJhbnNsYXRlL2NvcmVcIjtcblxuaW1wb3J0IHsgQ3VsdHVyZSB9IGZyb20gXCJAdGEvdXRpbHNcIjtcblxuaW1wb3J0IHsgVGFUcmFuc2xhdGlvblVJIH0gZnJvbSBcIi4uLy4uLy4uL3RyYW5zbGF0aW9uLnNlcnZpY2VcIjtcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiBcInRhLWN1bHR1cmVcIixcbiAgdGVtcGxhdGVVcmw6IFwiLi9jdWx0dXJlLmNvbXBvbmVudC5odG1sXCIsXG4gIHN0eWxlVXJsczogW1wiLi9jdWx0dXJlLmNvbXBvbmVudC5zY3NzXCJdLFxuICBzdGFuZGFsb25lOiB0cnVlLFxuICBpbXBvcnRzOiBbTmdGb3IsIFRyYW5zbGF0ZU1vZHVsZV0sXG59KVxuZXhwb3J0IGNsYXNzIEN1bHR1cmVDb21wb25lbnQge1xuICBjdWx0dXJlcyA9IGlucHV0LnJlcXVpcmVkPEN1bHR1cmVbXT4oKTtcblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBUYVRyYW5zbGF0aW9uVUkuZ2V0SW5zdGFuY2UoKTtcbiAgfVxufVxuIiwiPGRpdiBjbGFzcz1cImZsZXgtc3RhcnQgZy1zcGFjZS14c1wiPlxuICBAZm9yIChjdWx0dXJlIG9mIHRoaXMuY3VsdHVyZXMoKTsgdHJhY2sgY3VsdHVyZTsgbGV0IGlzTGFzdCA9ICRsYXN0KSB7XG4gIDxkaXY+XG4gICAge3sgXCJ1aS5jdWx0dXJlLnNob3J0LlwiICsgY3VsdHVyZSB8IHRyYW5zbGF0ZSB9fXt7ICFpc0xhc3QgPyBcIixcIiA6IFwiXCIgfX1cbiAgPC9kaXY+XG4gIH1cbjwvZGl2PlxuIl19