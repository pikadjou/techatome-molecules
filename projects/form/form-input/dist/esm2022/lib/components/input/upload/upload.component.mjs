import { NgIf, NgFor } from '@angular/common';
import { TranslateModule } from '@ngx-translate/core';
import { MatProgressBarModule } from '@angular/material/progress-bar';
import { FontIconComponent } from '@ta/icons';
import { ButtonComponent, TextComponent, MegaoctetComponent, LinkComponent, LoaderComponent } from '@ta/ui';
import { Component, EventEmitter, Output, ViewChild, inject } from '@angular/core';
import { FilePicker } from '@capawesome/capacitor-file-picker';
import { CamDocumentsService } from '@ta/services';
import { downloadFile, isNonNullable } from '@ta/utils';
import { CamAbstractInputComponent } from '../../abstract.component';
import * as i0 from "@angular/core";
import * as i1 from "@ngx-translate/core";
import * as i2 from "@angular/material/progress-bar";
export class UploadComponent extends CamAbstractInputComponent {
    constructor() {
        super();
        this.uploadStatusChanged = new EventEmitter();
        this._documentsService = inject(CamDocumentsService);
        this.inProgressFiles = [];
        this._invervalId = window.setInterval(() => {
            if (!this.inProgressFiles || this.inProgressFiles.length === 0) {
                return;
            }
            for (const file of this.inProgressFiles) {
                if (file.progress === 100) {
                    continue;
                }
                if (file.progress >= 95) {
                    continue;
                }
                file.progress += 5;
            }
        }, 1000);
    }
    ngOnInit() {
        super.ngOnInit();
        if (this.input.value && this.input.value.length > 0) {
            const ids = this.input.value.map(file => file.id);
            this.requestState.asked();
            this._documentsService.fetchDocuments$(ids).subscribe({
                next: () => {
                    const documents = this._documentsService.getDocuments(ids);
                    for (let doc of documents ?? []) {
                        this.inProgressFiles.push({
                            name: doc.name ?? '',
                            completed: doc,
                            progress: 100,
                        });
                    }
                    this.requestState.completed();
                },
            });
        }
    }
    ngOnDestroy() {
        window.clearInterval(this._invervalId);
    }
    onFileDropped($event) {
        this.prepareFilesList($event);
    }
    fileBrowseHandler(files) {
        this.prepareFilesList(files.files);
    }
    openDocument(doc) {
        downloadFile(doc.url);
    }
    isValidDocumentList() {
        if (this.inProgressFiles.length === 0) {
            return false;
        }
        return !this.inProgressFiles.find(file => file.progress < 100);
    }
    validation() {
        const values = this.inProgressFiles
            .map(file => file.completed
            ? {
                id: file.completed.id,
                name: file.completed.name ?? '',
                url: file.completed.url,
            }
            : null)
            .filter(isNonNullable);
        this.input.confirmValue(values);
    }
    deleteInProgressFile(name) {
        this.inProgressFiles = this.inProgressFiles.filter(file => file.name !== name);
        this._refreshUploadStatus();
    }
    deleteFile(id) {
        this.inProgressFiles = this.inProgressFiles.filter(file => file.completed?.id !== id);
        this._refreshUploadStatus();
    }
    prepareFilesList(files) {
        for (const item of files) {
            const inProgressFile = {
                name: item.name,
                progress: 0,
                completed: null,
            };
            this.inProgressFiles.push(inProgressFile);
            this.uploadStatusChanged.emit(false);
            this._documentsService.addDocument$({ file: item }).subscribe({
                next: data => {
                    inProgressFile.progress = 100;
                    inProgressFile.completed = data;
                    this._refreshUploadStatus();
                    if (!this.input.confirmButton) {
                        this.validation();
                    }
                },
            });
        }
    }
    async uploadFile() {
        // todo move into a capacitor filesystem service
        const pickFiles = await FilePicker.pickFiles({
            multiple: true,
            types: [
                // pdf
                'application/pdf',
                // word
                'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
                'application/msword',
                // excel
                'application/vnd.ms-excel',
                'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
                // text
                'text/plain',
            ],
        });
        const files = [];
        for (let file of pickFiles.files) {
            if (!file || !file.blob)
                continue;
            files.push(this._localToFile(file));
        }
        this.prepareFilesList(files);
    }
    _refreshUploadStatus() {
        const allComplete = this.inProgressFiles.every(file => file.progress === 100);
        this.uploadStatusChanged.emit(allComplete);
    }
    _localToFile(file) {
        return new File([file.blob], file.name, {
            type: file.mimeType,
        });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: UploadComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "18.2.13", type: UploadComponent, isStandalone: true, selector: "ta-input-upload", outputs: { uploadStatusChanged: "uploadStatusChanged" }, viewQueries: [{ propertyName: "fileDropEl", first: true, predicate: ["fileDropRef"], descendants: true }], usesInheritance: true, ngImport: i0, template: "<ta-loader [isLoading]=\"this.requestState.isLoading()\">\n  <div class=\"upload-container flex-column\" appDnd (fileDropped)=\"this.onFileDropped($event)\">\n    <div class=\"flex-responsive-ctr g-space-md\">\n      @if (this.inProgressFiles.length > 0) {\n        <div class=\"files-list flex-column g-space-sm\">\n          @for (item of this.inProgressFiles; track item) {\n            <div class=\"flex-column\">\n              <div class=\"flex-row align-center\">\n                <ta-font-icon name=\"doc\" size=\"xs\"></ta-font-icon>\n                @if (item.progress < 100) {\n                  <ta-text class=\"name\" size=\"sm\">\n                    {{ item.name }}\n                  </ta-text>\n                } @else if (item.progress === 100 && item.completed) {\n                  <ta-link class=\"name\" (action)=\"this.openDocument(item.completed)\" size=\"sm\">{{ item.name }}</ta-link>\n                }\n              </div>\n              <div class=\"extra flex-row g-space-md\">\n                @if (item.progress < 100) {\n                  <mat-progress-bar mode=\"determinate\" [value]=\"item.progress\"></mat-progress-bar>\n                  <ta-link (action)=\"this.deleteInProgressFile(item.name)\" [underline]=\"false\">\n                    <ta-font-icon name=\"close\" type=\"sm\"></ta-font-icon>\n                  </ta-link>\n                } @else if (item.progress === 100 && item.completed) {\n                  <ta-text size=\"sm\" class=\"justify-end\">\n                    <ta-megaoctet [octet]=\"item.completed.size\"></ta-megaoctet>\n                  </ta-text>\n                  @if (item.completed.id) {\n                    <ta-link (action)=\"this.deleteFile(item.completed.id)\" [underline]=\"false\">\n                      <ta-font-icon name=\"close\" type=\"sm\"></ta-font-icon>\n                    </ta-link>\n                  }\n                }\n              </div>\n            </div>\n          }\n        </div>\n      }\n      <div class=\"content ta-c\">\n        <input type=\"file\" multiple (change)=\"this.fileBrowseHandler($event.target)\" />\n        <h3>\n          {{ 'input.upload.dragndrop' | translate }}\n        </h3>\n        <div class=\"d-flex\">\n          <ta-button type=\"secondary\" icon=\"add\" class=\"m-a\" (action)=\"this.uploadFile()\">\n            {{ 'input.upload.add' | translate }}\n          </ta-button>\n        </div>\n      </div>\n    </div>\n    @if (this.input.confirmButton) {\n      <div class=\"d-flex\">\n        <ta-button\n          icon=\"check-line\"\n          class=\"justify-end align-center\"\n          (action)=\"this.validation()\"\n          size=\"small\"\n          [state]=\"this.isValidDocumentList() ? 'classic' : 'disabled'\"\n        >\n          {{ 'input.upload.confirm' | translate }}\n        </ta-button>\n      </div>\n    }\n  </div>\n</ta-loader>\n", styles: [".upload-container{display:flex;border:1px dotted var(--ta-border-primary);padding:var(--ta-space-md);gap:var(--ta-space-md)}.upload-container .files-list{width:50%;max-height:500px}.upload-container .files-list ta-font-icon{color:var(--ta-surface-brand-secondary)}.upload-container .files-list .name{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.upload-container .content{position:relative;background-color:var(--ta-surface-default);padding:var(--ta-space-xl);flex:1}.upload-container .content input{opacity:0;position:absolute;z-index:2;width:100%;height:100%;top:0;left:0;cursor:pointer}\n"], dependencies: [{ kind: "component", type: FontIconComponent, selector: "ta-font-icon", inputs: ["name", "type"] }, { kind: "component", type: ButtonComponent, selector: "ta-button", inputs: ["state", "type", "size", "icon", "options", "stopPropagationActivation"], outputs: ["action"] }, { kind: "ngmodule", type: TranslateModule }, { kind: "pipe", type: i1.TranslatePipe, name: "translate" }, { kind: "component", type: TextComponent, selector: "ta-text", inputs: ["size", "isBold", "color"] }, { kind: "component", type: MegaoctetComponent, selector: "ta-megaoctet", inputs: ["octet", "icon"] }, { kind: "component", type: LinkComponent, selector: "ta-link", inputs: ["state", "underline", "bold", "size", "icon"], outputs: ["action"] }, { kind: "component", type: LoaderComponent, selector: "ta-loader", inputs: ["isLoading", "skeleton"] }, { kind: "ngmodule", type: MatProgressBarModule }, { kind: "component", type: i2.MatProgressBar, selector: "mat-progress-bar", inputs: ["color", "value", "bufferValue", "mode"], outputs: ["animationEnd"], exportAs: ["matProgressBar"] }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: UploadComponent, decorators: [{
            type: Component,
            args: [{ selector: 'ta-input-upload', standalone: true, imports: [NgIf, NgFor, FontIconComponent, ButtonComponent, TranslateModule, TextComponent, MegaoctetComponent, LinkComponent, LoaderComponent, MatProgressBarModule], template: "<ta-loader [isLoading]=\"this.requestState.isLoading()\">\n  <div class=\"upload-container flex-column\" appDnd (fileDropped)=\"this.onFileDropped($event)\">\n    <div class=\"flex-responsive-ctr g-space-md\">\n      @if (this.inProgressFiles.length > 0) {\n        <div class=\"files-list flex-column g-space-sm\">\n          @for (item of this.inProgressFiles; track item) {\n            <div class=\"flex-column\">\n              <div class=\"flex-row align-center\">\n                <ta-font-icon name=\"doc\" size=\"xs\"></ta-font-icon>\n                @if (item.progress < 100) {\n                  <ta-text class=\"name\" size=\"sm\">\n                    {{ item.name }}\n                  </ta-text>\n                } @else if (item.progress === 100 && item.completed) {\n                  <ta-link class=\"name\" (action)=\"this.openDocument(item.completed)\" size=\"sm\">{{ item.name }}</ta-link>\n                }\n              </div>\n              <div class=\"extra flex-row g-space-md\">\n                @if (item.progress < 100) {\n                  <mat-progress-bar mode=\"determinate\" [value]=\"item.progress\"></mat-progress-bar>\n                  <ta-link (action)=\"this.deleteInProgressFile(item.name)\" [underline]=\"false\">\n                    <ta-font-icon name=\"close\" type=\"sm\"></ta-font-icon>\n                  </ta-link>\n                } @else if (item.progress === 100 && item.completed) {\n                  <ta-text size=\"sm\" class=\"justify-end\">\n                    <ta-megaoctet [octet]=\"item.completed.size\"></ta-megaoctet>\n                  </ta-text>\n                  @if (item.completed.id) {\n                    <ta-link (action)=\"this.deleteFile(item.completed.id)\" [underline]=\"false\">\n                      <ta-font-icon name=\"close\" type=\"sm\"></ta-font-icon>\n                    </ta-link>\n                  }\n                }\n              </div>\n            </div>\n          }\n        </div>\n      }\n      <div class=\"content ta-c\">\n        <input type=\"file\" multiple (change)=\"this.fileBrowseHandler($event.target)\" />\n        <h3>\n          {{ 'input.upload.dragndrop' | translate }}\n        </h3>\n        <div class=\"d-flex\">\n          <ta-button type=\"secondary\" icon=\"add\" class=\"m-a\" (action)=\"this.uploadFile()\">\n            {{ 'input.upload.add' | translate }}\n          </ta-button>\n        </div>\n      </div>\n    </div>\n    @if (this.input.confirmButton) {\n      <div class=\"d-flex\">\n        <ta-button\n          icon=\"check-line\"\n          class=\"justify-end align-center\"\n          (action)=\"this.validation()\"\n          size=\"small\"\n          [state]=\"this.isValidDocumentList() ? 'classic' : 'disabled'\"\n        >\n          {{ 'input.upload.confirm' | translate }}\n        </ta-button>\n      </div>\n    }\n  </div>\n</ta-loader>\n", styles: [".upload-container{display:flex;border:1px dotted var(--ta-border-primary);padding:var(--ta-space-md);gap:var(--ta-space-md)}.upload-container .files-list{width:50%;max-height:500px}.upload-container .files-list ta-font-icon{color:var(--ta-surface-brand-secondary)}.upload-container .files-list .name{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.upload-container .content{position:relative;background-color:var(--ta-surface-default);padding:var(--ta-space-xl);flex:1}.upload-container .content input{opacity:0;position:absolute;z-index:2;width:100%;height:100%;top:0;left:0;cursor:pointer}\n"] }]
        }], ctorParameters: () => [], propDecorators: { uploadStatusChanged: [{
                type: Output
            }], fileDropEl: [{
                type: ViewChild,
                args: ['fileDropRef', { static: false }]
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXBsb2FkLmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3NyYy9saWIvY29tcG9uZW50cy9pbnB1dC91cGxvYWQvdXBsb2FkLmNvbXBvbmVudC50cyIsIi4uLy4uLy4uLy4uLy4uLy4uL3NyYy9saWIvY29tcG9uZW50cy9pbnB1dC91cGxvYWQvdXBsb2FkLmNvbXBvbmVudC5odG1sIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxJQUFJLEVBQUUsS0FBSyxFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFDOUMsT0FBTyxFQUFFLGVBQWUsRUFBRSxNQUFNLHFCQUFxQixDQUFDO0FBQ3RELE9BQU8sRUFBRSxvQkFBb0IsRUFBRSxNQUFNLGdDQUFnQyxDQUFDO0FBQ3RFLE9BQU8sRUFBRSxpQkFBaUIsRUFBRSxNQUFNLFdBQVcsQ0FBQztBQUM5QyxPQUFPLEVBQUUsZUFBZSxFQUFFLGFBQWEsRUFBRSxrQkFBa0IsRUFBRSxhQUFhLEVBQUUsZUFBZSxFQUFFLE1BQU0sUUFBUSxDQUFDO0FBQzVHLE9BQU8sRUFBRSxTQUFTLEVBQWMsWUFBWSxFQUFVLE1BQU0sRUFBRSxTQUFTLEVBQUUsTUFBTSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBRXZHLE9BQU8sRUFBRSxVQUFVLEVBQWMsTUFBTSxtQ0FBbUMsQ0FBQztBQUUzRSxPQUFPLEVBQUUsbUJBQW1CLEVBQWUsTUFBTSxjQUFjLENBQUM7QUFDaEUsT0FBTyxFQUFFLFlBQVksRUFBRSxhQUFhLEVBQUUsTUFBTSxXQUFXLENBQUM7QUFFeEQsT0FBTyxFQUFFLHlCQUF5QixFQUFFLE1BQU0sMEJBQTBCLENBQUM7Ozs7QUFlckUsTUFBTSxPQUFPLGVBQWdCLFNBQVEseUJBQXNDO0lBVXpFO1FBQ0UsS0FBSyxFQUFFLENBQUM7UUFWQSx3QkFBbUIsR0FBRyxJQUFJLFlBQVksRUFBVyxDQUFDO1FBSTNDLHNCQUFpQixHQUFHLE1BQU0sQ0FBQyxtQkFB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QyxDQUFDO0lBQy9CLENBQUM7SUFFTyxvQkFBb0I7UUFDMUIsTUFBTSxXQUFXLEdBQUcsSUFBSSxDQUFDLGVBQWUsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsUUFBUSxLQUFLLEdBQUcsQ0FBQyxDQUFDO1FBQzlFLElBQUksQ0FBQyxtQkFBbUIsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLENBQUM7SUFDN0MsQ0FBQztJQUVPLFlBQVksQ0FBQyxJQUFnQjtRQUNuQyxPQUFPLElBQUksSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUssQ0FBQyxFQUFFLElBQUksQ0FBQyxJQUFJLEVBQUU7WUFDdkMsSUFBSSxFQUFFLElBQUksQ0FBQyxRQUFRO1NBQ3BCLENBQUMsQ0FBQztJQUNMLENBQUM7K0dBM0pVLGVBQWU7bUdBQWYsZUFBZSxzUUMzQjVCLDgwRkFpRUEsc3BCRHhDeUIsaUJBQWlCLG1GQUFFLGVBQWUsNkpBQUUsZUFBZSw0RkFBRSxhQUFhLHlGQUFFLGtCQUFrQixvRkFBRSxhQUFhLGlJQUFFLGVBQWUsd0ZBQUUsb0JBQW9COzs0RkFFeEosZUFBZTtrQkFQM0IsU0FBUzsrQkFDQSxpQkFBaUIsY0FHYixJQUFJLFdBQ1AsQ0FBQyxJQUFJLEVBQUUsS0FBSyxFQUFFLGlCQUFpQixFQUFFLGVBQWUsRUFBRSxlQUFlLEVBQUUsYUFBYSxFQUFFLGtCQUFrQixFQUFFLGFBQWEsRUFBRSxlQUFlLEVBQUUsb0JBQW9CLENBQUM7d0RBRzFKLG1CQUFtQjtzQkFBNUIsTUFBTTtnQkFFc0MsVUFBVTtzQkFBdEQsU0FBUzt1QkFBQyxhQUFhLEVBQUUsRUFBRSxNQUFNLEVBQUUsS0FBSyxFQUFFIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTmdJZiwgTmdGb3IgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgVHJhbnNsYXRlTW9kdWxlIH0gZnJvbSAnQG5neC10cmFuc2xhdGUvY29yZSc7XG5pbXBvcnQgeyBNYXRQcm9ncmVzc0Jhck1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL21hdGVyaWFsL3Byb2dyZXNzLWJhcic7XG5pbXBvcnQgeyBGb250SWNvbkNvbXBvbmVudCB9IGZyb20gJ0B0YS9pY29ucyc7XG5pbXBvcnQgeyBCdXR0b25Db21wb25lbnQsIFRleHRDb21wb25lbnQsIE1lZ2FvY3RldENvbXBvbmVudCwgTGlua0NvbXBvbmVudCwgTG9hZGVyQ29tcG9uZW50IH0gZnJvbSAnQHRhL3VpJztcbmltcG9ydCB7IENvbXBvbmVudCwgRWxlbWVudFJlZiwgRXZlbnRFbWl0dGVyLCBPbkluaXQsIE91dHB1dCwgVmlld0NoaWxkLCBpbmplY3QgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHsgRmlsZVBpY2tlciwgUGlja2VkRmlsZSB9IGZyb20gJ0BjYXBhd2Vzb21lL2NhcGFjaXRvci1maWxlLXBpY2tlcic7XG5pbXBvcnQgeyBJbnB1dFVwbG9hZCwgSW5wdXRVcGxvYWRWYWx1ZSB9IGZyb20gJ0B0YS9mb3JtLW1vZGVsJztcbmltcG9ydCB7IENhbURvY3VtZW50c1NlcnZpY2UsIERvY3VtZW50RHRvIH0gZnJvbSAnQHRhL3NlcnZpY2VzJztcbmltcG9ydCB7IGRvd25sb2FkRmlsZSwgaXNOb25OdWxsYWJsZSB9IGZyb20gJ0B0YS91dGlscyc7XG5cbmltcG9ydCB7IENhbUFic3RyYWN0SW5wdXRDb21wb25lbnQgfSBmcm9tICcuLi8uLi9hYnN0cmFjdC5jb21wb25lbnQnO1xuXG50eXBlIEluUHJvZ3Jlc3NGaWxlID0ge1xuICBuYW1lOiBzdHJpbmc7XG4gIHByb2dyZXNzOiBudW1iZXI7XG4gIGNvbXBsZXRlZDogRG9jdW1lbnREdG8gfCBudWxsO1xufTtcblxuQENvbXBvbmVudCh7XG5zZWxlY3RvcjogJ3RhLWlucHV0LXVwbG9hZCcsXG4gIHRlbXBsYXRlVXJsOiAnLi91cGxvYWQuY29tcG9uZW50Lmh0bWwnLFxuICBzdHlsZVVybHM6IFsnLi91cGxvYWQuY29tcG9uZW50LnNjc3MnXSxcbiAgc3RhbmRhbG9uZTogdHJ1ZSxcbiAgaW1wb3J0czogW05nSWYsIE5nRm9yLCBGb250SWNvbkNvbXBvbmVudCwgQnV0dG9uQ29tcG9uZW50LCBUcmFuc2xhdGVNb2R1bGUsIFRleHRDb21wb25lbnQsIE1lZ2FvY3RldENvbXBvbmVudCwgTGlua0NvbXBvbmVudCwgTG9hZGVyQ29tcG9uZW50LCBNYXRQcm9ncmVzc0Jhck1vZHVsZV0sXG59KVxuZXhwb3J0IGNsYXNzIFVwbG9hZENvbXBvbmVudCBleHRlbmRzIENhbUFic3RyYWN0SW5wdXRDb21wb25lbnQ8SW5wdXRVcGxvYWQ+IGltcGxlbWVudHMgT25Jbml0IHtcbiAgQE91dHB1dCgpIHVwbG9hZFN0YXR1c0NoYW5nZWQgPSBuZXcgRXZlbnRFbWl0dGVyPGJvb2xlYW4+KCk7XG5cbiAgQFZpZXdDaGlsZCgnZmlsZURyb3BSZWYnLCB7IHN0YXRpYzogZmFsc2UgfSkgZmlsZURyb3BFbCE6IEVsZW1lbnRSZWY7XG5cbiAgcHJpdmF0ZSByZWFkb25seSBfZG9jdW1lbnRzU2VydmljZSA9IGluamVjdChDYW1Eb2N1bWVudHNTZXJ2aWNlKTtcbiAgcHJpdmF0ZSBfaW52ZXJ2YWxJZDogbnVtYmVyO1xuXG4gIHB1YmxpYyBpblByb2dyZXNzRmlsZXM6IEluUHJvZ3Jlc3NGaWxlW10gPSBbXTtcblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgdGhpcy5faW52ZXJ2YWxJZCA9IHdpbmRvdy5zZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICBpZiAoIXRoaXMuaW5Qcm9ncmVzc0ZpbGVzIHx8IHRoaXMuaW5Qcm9ncmVzc0ZpbGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IGZpbGUgb2YgdGhpcy5pblByb2dyZXNzRmlsZXMpIHtcbiAgICAgICAgaWYgKGZpbGUucHJvZ3Jlc3MgPT09IDEwMCkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmaWxlLnByb2dyZXNzID49IDk1KSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgZmlsZS5wcm9ncmVzcyArPSA1O1xuICAgICAgfVxuICAgIH0sIDEwMDApO1xuICB9XG5cbiAgb3ZlcnJpZGUgbmdPbkluaXQoKSB7XG4gICAgc3VwZXIubmdPbkluaXQoKTtcbiAgICBpZiAodGhpcy5pbnB1dC52YWx1ZSAmJiB0aGlzLmlucHV0LnZhbHVlLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IGlkcyA9IHRoaXMuaW5wdXQudmFsdWUubWFwKGZpbGUgPT4gZmlsZS5pZCk7XG4gICAgICB0aGlzLnJlcXVlc3RTdGF0ZS5hc2tlZCgpO1xuICAgICAgdGhpcy5fZG9jdW1lbnRzU2VydmljZS5mZXRjaERvY3VtZW50cyQoaWRzKS5zdWJzY3JpYmUoe1xuICAgICAgICBuZXh0OiAoKSA9PiB7XG4gICAgICAgICAgY29uc3QgZG9jdW1lbnRzID0gdGhpcy5fZG9jdW1lbnRzU2VydmljZS5nZXREb2N1bWVudHMoaWRzKTtcbiAgICAgICAgICBmb3IgKGxldCBkb2Mgb2YgZG9jdW1lbnRzID8/IFtdKSB7XG4gICAgICAgICAgICB0aGlzLmluUHJvZ3Jlc3NGaWxlcy5wdXNoKHtcbiAgICAgICAgICAgICAgbmFtZTogZG9jLm5hbWUgPz8gJycsXG4gICAgICAgICAgICAgIGNvbXBsZXRlZDogZG9jLFxuICAgICAgICAgICAgICBwcm9ncmVzczogMTAwLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMucmVxdWVzdFN0YXRlLmNvbXBsZXRlZCgpO1xuICAgICAgICB9LFxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIG92ZXJyaWRlIG5nT25EZXN0cm95KCk6IHZvaWQge1xuICAgIHdpbmRvdy5jbGVhckludGVydmFsKHRoaXMuX2ludmVydmFsSWQpO1xuICB9XG4gIHB1YmxpYyBvbkZpbGVEcm9wcGVkKCRldmVudDogYW55KSB7XG4gICAgdGhpcy5wcmVwYXJlRmlsZXNMaXN0KCRldmVudCk7XG4gIH1cblxuICBwdWJsaWMgZmlsZUJyb3dzZUhhbmRsZXIoZmlsZXM6IGFueSkge1xuICAgIHRoaXMucHJlcGFyZUZpbGVzTGlzdChmaWxlcy5maWxlcyk7XG4gIH1cblxuICBwdWJsaWMgb3BlbkRvY3VtZW50KGRvYzogRG9jdW1lbnREdG8pIHtcbiAgICBkb3dubG9hZEZpbGUoZG9jLnVybCk7XG4gIH1cblxuICBwdWJsaWMgaXNWYWxpZERvY3VtZW50TGlzdCgpIHtcbiAgICBpZiAodGhpcy5pblByb2dyZXNzRmlsZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiAhdGhpcy5pblByb2dyZXNzRmlsZXMuZmluZChmaWxlID0+IGZpbGUucHJvZ3Jlc3MgPCAxMDApO1xuICB9XG4gIHB1YmxpYyB2YWxpZGF0aW9uKCkge1xuICAgIGNvbnN0IHZhbHVlczogSW5wdXRVcGxvYWRWYWx1ZVtdID0gdGhpcy5pblByb2dyZXNzRmlsZXNcbiAgICAgIC5tYXAoZmlsZSA9PlxuICAgICAgICBmaWxlLmNvbXBsZXRlZFxuICAgICAgICAgID8ge1xuICAgICAgICAgICAgICBpZDogZmlsZS5jb21wbGV0ZWQuaWQsXG4gICAgICAgICAgICAgIG5hbWU6IGZpbGUuY29tcGxldGVkLm5hbWUgPz8gJycsXG4gICAgICAgICAgICAgIHVybDogZmlsZS5jb21wbGV0ZWQudXJsLFxuICAgICAgICAgICAgfVxuICAgICAgICAgIDogbnVsbFxuICAgICAgKVxuICAgICAgLmZpbHRlcihpc05vbk51bGxhYmxlKTtcblxuICAgIHRoaXMuaW5wdXQuY29uZmlybVZhbHVlKHZhbHVlcyk7XG4gIH1cblxuICBwdWJsaWMgZGVsZXRlSW5Qcm9ncmVzc0ZpbGUobmFtZTogc3RyaW5nKSB7XG4gICAgdGhpcy5pblByb2dyZXNzRmlsZXMgPSB0aGlzLmluUHJvZ3Jlc3NGaWxlcy5maWx0ZXIoZmlsZSA9PiBmaWxlLm5hbWUgIT09IG5hbWUpO1xuICAgIHRoaXMuX3JlZnJlc2hVcGxvYWRTdGF0dXMoKTtcbiAgfVxuICBwdWJsaWMgZGVsZXRlRmlsZShpZDogc3RyaW5nKSB7XG4gICAgdGhpcy5pblByb2dyZXNzRmlsZXMgPSB0aGlzLmluUHJvZ3Jlc3NGaWxlcy5maWx0ZXIoZmlsZSA9PiBmaWxlLmNvbXBsZXRlZD8uaWQgIT09IGlkKTtcbiAgICB0aGlzLl9yZWZyZXNoVXBsb2FkU3RhdHVzKCk7XG4gIH1cblxuICBwdWJsaWMgcHJlcGFyZUZpbGVzTGlzdChmaWxlczogRmlsZVtdKSB7XG4gICAgZm9yIChjb25zdCBpdGVtIG9mIGZpbGVzKSB7XG4gICAgICBjb25zdCBpblByb2dyZXNzRmlsZTogSW5Qcm9ncmVzc0ZpbGUgPSB7XG4gICAgICAgIG5hbWU6IGl0ZW0ubmFtZSxcbiAgICAgICAgcHJvZ3Jlc3M6IDAsXG4gICAgICAgIGNvbXBsZXRlZDogbnVsbCxcbiAgICAgIH07XG4gICAgICB0aGlzLmluUHJvZ3Jlc3NGaWxlcy5wdXNoKGluUHJvZ3Jlc3NGaWxlKTtcbiAgICAgIHRoaXMudXBsb2FkU3RhdHVzQ2hhbmdlZC5lbWl0KGZhbHNlKTtcblxuICAgICAgdGhpcy5fZG9jdW1lbnRzU2VydmljZS5hZGREb2N1bWVudCQoeyBmaWxlOiBpdGVtIH0pLnN1YnNjcmliZSh7XG4gICAgICAgIG5leHQ6IGRhdGEgPT4ge1xuICAgICAgICAgIGluUHJvZ3Jlc3NGaWxlLnByb2dyZXNzID0gMTAwO1xuICAgICAgICAgIGluUHJvZ3Jlc3NGaWxlLmNvbXBsZXRlZCA9IGRhdGE7XG5cbiAgICAgICAgICB0aGlzLl9yZWZyZXNoVXBsb2FkU3RhdHVzKCk7XG4gICAgICAgICAgaWYgKCF0aGlzLmlucHV0LmNvbmZpcm1CdXR0b24pIHtcbiAgICAgICAgICAgIHRoaXMudmFsaWRhdGlvbigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBhc3luYyB1cGxvYWRGaWxlKCkge1xuICAgIC8vIHRvZG8gbW92ZSBpbnRvIGEgY2FwYWNpdG9yIGZpbGVzeXN0ZW0gc2VydmljZVxuICAgIGNvbnN0IHBpY2tGaWxlcyA9IGF3YWl0IEZpbGVQaWNrZXIucGlja0ZpbGVzKHtcbiAgICAgIG11bHRpcGxlOiB0cnVlLFxuICAgICAgdHlwZXM6IFtcbiAgICAgICAgLy8gcGRmXG4gICAgICAgICdhcHBsaWNhdGlvbi9wZGYnLFxuICAgICAgICAvLyB3b3JkXG4gICAgICAgICdhcHBsaWNhdGlvbi92bmQub3BlbnhtbGZvcm1hdHMtb2ZmaWNlZG9jdW1lbnQud29yZHByb2Nlc3NpbmdtbC5kb2N1bWVudCcsXG4gICAgICAgICdhcHBsaWNhdGlvbi9tc3dvcmQnLFxuICAgICAgICAvLyBleGNlbFxuICAgICAgICAnYXBwbGljYXRpb24vdm5kLm1zLWV4Y2VsJyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC5zcHJlYWRzaGVldG1sLnNoZWV0JyxcbiAgICAgICAgLy8gdGV4dFxuICAgICAgICAndGV4dC9wbGFpbicsXG4gICAgICBdLFxuICAgIH0pO1xuXG4gICAgY29uc3QgZmlsZXMgPSBbXTtcbiAgICBmb3IgKGxldCBmaWxlIG9mIHBpY2tGaWxlcy5maWxlcykge1xuICAgICAgaWYgKCFmaWxlIHx8ICFmaWxlLmJsb2IpIGNvbnRpbnVlO1xuXG4gICAgICBmaWxlcy5wdXNoKHRoaXMuX2xvY2FsVG9GaWxlKGZpbGUpKTtcbiAgICB9XG4gICAgdGhpcy5wcmVwYXJlRmlsZXNMaXN0KGZpbGVzKTtcbiAgfVxuXG4gIHByaXZhdGUgX3JlZnJlc2hVcGxvYWRTdGF0dXMoKSB7XG4gICAgY29uc3QgYWxsQ29tcGxldGUgPSB0aGlzLmluUHJvZ3Jlc3NGaWxlcy5ldmVyeShmaWxlID0+IGZpbGUucHJvZ3Jlc3MgPT09IDEwMCk7XG4gICAgdGhpcy51cGxvYWRTdGF0dXNDaGFuZ2VkLmVtaXQoYWxsQ29tcGxldGUpO1xuICB9XG5cbiAgcHJpdmF0ZSBfbG9jYWxUb0ZpbGUoZmlsZTogUGlja2VkRmlsZSk6IEZpbGUge1xuICAgIHJldHVybiBuZXcgRmlsZShbZmlsZS5ibG9iIV0sIGZpbGUubmFtZSwge1xuICAgICAgdHlwZTogZmlsZS5taW1lVHlwZSxcbiAgICB9KTtcbiAgfVxufVxuIiwiPHRhLWxvYWRlciBbaXNMb2FkaW5nXT1cInRoaXMucmVxdWVzdFN0YXRlLmlzTG9hZGluZygpXCI+XG4gIDxkaXYgY2xhc3M9XCJ1cGxvYWQtY29udGFpbmVyIGZsZXgtY29sdW1uXCIgYXBwRG5kIChmaWxlRHJvcHBlZCk9XCJ0aGlzLm9uRmlsZURyb3BwZWQoJGV2ZW50KVwiPlxuICAgIDxkaXYgY2xhc3M9XCJmbGV4LXJlc3BvbnNpdmUtY3RyIGctc3BhY2UtbWRcIj5cbiAgICAgIEBpZiAodGhpcy5pblByb2dyZXNzRmlsZXMubGVuZ3RoID4gMCkge1xuICAgICAgICA8ZGl2IGNsYXNzPVwiZmlsZXMtbGlzdCBmbGV4LWNvbHVtbiBnLXNwYWNlLXNtXCI+XG4gICAgICAgICAgQGZvciAoaXRlbSBvZiB0aGlzLmluUHJvZ3Jlc3NGaWxlczsgdHJhY2sgaXRlbSkge1xuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImZsZXgtY29sdW1uXCI+XG4gICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJmbGV4LXJvdyBhbGlnbi1jZW50ZXJcIj5cbiAgICAgICAgICAgICAgICA8dGEtZm9udC1pY29uIG5hbWU9XCJkb2NcIiBzaXplPVwieHNcIj48L3RhLWZvbnQtaWNvbj5cbiAgICAgICAgICAgICAgICBAaWYgKGl0ZW0ucHJvZ3Jlc3MgPCAxMDApIHtcbiAgICAgICAgICAgICAgICAgIDx0YS10ZXh0IGNsYXNzPVwibmFtZVwiIHNpemU9XCJzbVwiPlxuICAgICAgICAgICAgICAgICAgICB7eyBpdGVtLm5hbWUgfX1cbiAgICAgICAgICAgICAgICAgIDwvdGEtdGV4dD5cbiAgICAgICAgICAgICAgICB9IEBlbHNlIGlmIChpdGVtLnByb2dyZXNzID09PSAxMDAgJiYgaXRlbS5jb21wbGV0ZWQpIHtcbiAgICAgICAgICAgICAgICAgIDx0YS1saW5rIGNsYXNzPVwibmFtZVwiIChhY3Rpb24pPVwidGhpcy5vcGVuRG9jdW1lbnQoaXRlbS5jb21wbGV0ZWQpXCIgc2l6ZT1cInNtXCI+e3sgaXRlbS5uYW1lIH19PC90YS1saW5rPlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJleHRyYSBmbGV4LXJvdyBnLXNwYWNlLW1kXCI+XG4gICAgICAgICAgICAgICAgQGlmIChpdGVtLnByb2dyZXNzIDwgMTAwKSB7XG4gICAgICAgICAgICAgICAgICA8bWF0LXByb2dyZXNzLWJhciBtb2RlPVwiZGV0ZXJtaW5hdGVcIiBbdmFsdWVdPVwiaXRlbS5wcm9ncmVzc1wiPjwvbWF0LXByb2dyZXNzLWJhcj5cbiAgICAgICAgICAgICAgICAgIDx0YS1saW5rIChhY3Rpb24pPVwidGhpcy5kZWxldGVJblByb2dyZXNzRmlsZShpdGVtLm5hbWUpXCIgW3VuZGVybGluZV09XCJmYWxzZVwiPlxuICAgICAgICAgICAgICAgICAgICA8dGEtZm9udC1pY29uIG5hbWU9XCJjbG9zZVwiIHR5cGU9XCJzbVwiPjwvdGEtZm9udC1pY29uPlxuICAgICAgICAgICAgICAgICAgPC90YS1saW5rPlxuICAgICAgICAgICAgICAgIH0gQGVsc2UgaWYgKGl0ZW0ucHJvZ3Jlc3MgPT09IDEwMCAmJiBpdGVtLmNvbXBsZXRlZCkge1xuICAgICAgICAgICAgICAgICAgPHRhLXRleHQgc2l6ZT1cInNtXCIgY2xhc3M9XCJqdXN0aWZ5LWVuZFwiPlxuICAgICAgICAgICAgICAgICAgICA8dGEtbWVnYW9jdGV0IFtvY3RldF09XCJpdGVtLmNvbXBsZXRlZC5zaXplXCI+PC90YS1tZWdhb2N0ZXQ+XG4gICAgICAgICAgICAgICAgICA8L3RhLXRleHQ+XG4gICAgICAgICAgICAgICAgICBAaWYgKGl0ZW0uY29tcGxldGVkLmlkKSB7XG4gICAgICAgICAgICAgICAgICAgIDx0YS1saW5rIChhY3Rpb24pPVwidGhpcy5kZWxldGVGaWxlKGl0ZW0uY29tcGxldGVkLmlkKVwiIFt1bmRlcmxpbmVdPVwiZmFsc2VcIj5cbiAgICAgICAgICAgICAgICAgICAgICA8dGEtZm9udC1pY29uIG5hbWU9XCJjbG9zZVwiIHR5cGU9XCJzbVwiPjwvdGEtZm9udC1pY29uPlxuICAgICAgICAgICAgICAgICAgICA8L3RhLWxpbms+XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIH1cbiAgICAgICAgPC9kaXY+XG4gICAgICB9XG4gICAgICA8ZGl2IGNsYXNzPVwiY29udGVudCB0YS1jXCI+XG4gICAgICAgIDxpbnB1dCB0eXBlPVwiZmlsZVwiIG11bHRpcGxlIChjaGFuZ2UpPVwidGhpcy5maWxlQnJvd3NlSGFuZGxlcigkZXZlbnQudGFyZ2V0KVwiIC8+XG4gICAgICAgIDxoMz5cbiAgICAgICAgICB7eyAnaW5wdXQudXBsb2FkLmRyYWduZHJvcCcgfCB0cmFuc2xhdGUgfX1cbiAgICAgICAgPC9oMz5cbiAgICAgICAgPGRpdiBjbGFzcz1cImQtZmxleFwiPlxuICAgICAgICAgIDx0YS1idXR0b24gdHlwZT1cInNlY29uZGFyeVwiIGljb249XCJhZGRcIiBjbGFzcz1cIm0tYVwiIChhY3Rpb24pPVwidGhpcy51cGxvYWRGaWxlKClcIj5cbiAgICAgICAgICAgIHt7ICdpbnB1dC51cGxvYWQuYWRkJyB8IHRyYW5zbGF0ZSB9fVxuICAgICAgICAgIDwvdGEtYnV0dG9uPlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuICAgIEBpZiAodGhpcy5pbnB1dC5jb25maXJtQnV0dG9uKSB7XG4gICAgICA8ZGl2IGNsYXNzPVwiZC1mbGV4XCI+XG4gICAgICAgIDx0YS1idXR0b25cbiAgICAgICAgICBpY29uPVwiY2hlY2stbGluZVwiXG4gICAgICAgICAgY2xhc3M9XCJqdXN0aWZ5LWVuZCBhbGlnbi1jZW50ZXJcIlxuICAgICAgICAgIChhY3Rpb24pPVwidGhpcy52YWxpZGF0aW9uKClcIlxuICAgICAgICAgIHNpemU9XCJzbWFsbFwiXG4gICAgICAgICAgW3N0YXRlXT1cInRoaXMuaXNWYWxpZERvY3VtZW50TGlzdCgpID8gJ2NsYXNzaWMnIDogJ2Rpc2FibGVkJ1wiXG4gICAgICAgID5cbiAgICAgICAgICB7eyAnaW5wdXQudXBsb2FkLmNvbmZpcm0nIHwgdHJhbnNsYXRlIH19XG4gICAgICAgIDwvdGEtYnV0dG9uPlxuICAgICAgPC9kaXY+XG4gICAgfVxuICA8L2Rpdj5cbjwvdGEtbG9hZGVyPlxuIl19