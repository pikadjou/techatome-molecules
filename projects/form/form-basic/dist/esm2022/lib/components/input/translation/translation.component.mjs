import { NgClass, NgFor, NgIf, NgTemplateOutlet } from '@angular/common';
import { Component, input } from '@angular/core';
import { MatMenuModule } from '@angular/material/menu';
import { FontIconComponent } from '@ta/icons';
import { Menu, MenuBase } from '@ta/menu';
import { TranslatePipe } from '@ta/translation';
import { ButtonComponent, LinkComponent, TitleComponent } from '@ta/ui';
import { Culture, TaBaseComponent, extractEnum } from '@ta/utils';
import * as i0 from "@angular/core";
import * as i1 from "@angular/material/menu";
export class InputTranslationComponent extends TaBaseComponent {
    // Getter for backward compatibility
    get input() {
        return this.inputModel();
    }
    constructor() {
        super();
        this.inputModel = input.required({ alias: 'input' });
        this.inputsTemplate = input.required();
        this.cultureList = extractEnum(Culture, true);
        this.cultureMenu = null;
        this.currentCulture = Culture[Culture.FR_BE];
    }
    ngOnInit() {
        this._registerSubscription(this.input.listChanged$.subscribe({
            next: () => this._renderMenu(),
        }));
        this._renderMenu();
    }
    changeSelection(culture) {
        this.currentCulture = culture;
    }
    add(culture) {
        this.input.add(culture);
        this.changeSelection(culture);
    }
    remove(culture) {
        this.input.remove(culture);
    }
    hasKey(culture) {
        return this.getKeys().includes(culture);
    }
    getKeys() {
        return Object.keys(this.input.inputsGroup);
    }
    getInputs(culture) {
        return this.input.inputsGroup[culture];
    }
    trackByFn(_, key) {
        return key;
    }
    trackInputByFn(_, input) {
        return input.key;
    }
    _renderMenu() {
        this.cultureMenu = new Menu({
            elements: this.getKeys().map(cul => new MenuBase({
                key: cul,
                label: cul,
                order: 1,
                defaultOpen: this.currentCulture === cul,
                callback: () => this.changeSelection(cul),
            })),
            direction: 'horizontal',
        });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.14", ngImport: i0, type: InputTranslationComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "18.2.14", type: InputTranslationComponent, isStandalone: true, selector: "ta-input-translation", inputs: { inputModel: { classPropertyName: "inputModel", publicName: "input", isSignal: true, isRequired: true, transformFunction: null }, inputsTemplate: { classPropertyName: "inputsTemplate", publicName: "inputsTemplate", isSignal: true, isRequired: true, transformFunction: null } }, usesInheritance: true, ngImport: i0, template: "<div class=\"translation-container\">\n  @if (this.input.label) {\n    <ta-title [level]=\"3\" [isBold]=\"true\">{{ this.input.label | translate }}</ta-title>\n  }\n  <div class=\"flex-row align-center g-space-md\">\n    @if (this.cultureMenu) {\n      cultureMenu\n      <!-- <ta-toggle-navigation\n      [menu]=\"this.cultureMenu\"\n      container=\"tab\"\n    ></ta-toggle-navigation> -->\n    }\n    <ta-button size=\"small\" [matMenuTriggerFor]=\"menu\" [stopPropagationActivation]=\"false\">+</ta-button>\n  </div>\n\n  <div class=\"pt-space-md\">\n    @for (input of this.getInputs(this.currentCulture); track input) {\n      @if (input) {\n        <div [ngClass]=\"input.class\">\n          <ng-container\n            [ngTemplateOutlet]=\"this.inputsTemplate()\"\n            [ngTemplateOutletContext]=\"{\n              input: input,\n            }\"\n          ></ng-container>\n        </div>\n      }\n    }\n  </div>\n</div>\n\n<mat-menu #menu=\"matMenu\">\n  @for (culture of this.cultureList; track culture) {\n    <div>\n      <div class=\"flex-row g-space-sm p-space-sm\">\n        @if (this.hasKey(culture.name)) {\n          <ta-font-icon name=\"check-line\" class=\"checked\"></ta-font-icon>\n          <ta-link (action)=\"this.remove(culture.name)\">{{ culture.name }}</ta-link>\n        } @else {\n          <ta-font-icon name=\"check-line\"></ta-font-icon>\n          <ta-link (action)=\"this.add(culture.name)\">{{ culture.name }}</ta-link>\n        }\n      </div>\n    </div>\n  }\n</mat-menu>\n", styles: [".checked{color:var(--ta-semantic-token-success)}.translation-container{padding:var(--ta-space-md);border-radius:var(--ta-radius-rounded);border:1px solid var(--ta-border-secondary)}\n"], dependencies: [{ kind: "directive", type: NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }, { kind: "component", type: FontIconComponent, selector: "ta-font-icon", inputs: ["name", "type"] }, { kind: "ngmodule", type: MatMenuModule }, { kind: "component", type: i1.MatMenu, selector: "mat-menu", inputs: ["backdropClass", "aria-label", "aria-labelledby", "aria-describedby", "xPosition", "yPosition", "overlapTrigger", "hasBackdrop", "class", "classList"], outputs: ["closed", "close"], exportAs: ["matMenu"] }, { kind: "directive", type: i1.MatMenuTrigger, selector: "[mat-menu-trigger-for], [matMenuTriggerFor]", inputs: ["mat-menu-trigger-for", "matMenuTriggerFor", "matMenuTriggerData", "matMenuTriggerRestoreFocus"], outputs: ["menuOpened", "onMenuOpen", "menuClosed", "onMenuClose"], exportAs: ["matMenuTrigger"] }, { kind: "component", type: TitleComponent, selector: "ta-title", inputs: ["level", "isTheme", "isBold", "icon"] }, { kind: "component", type: LinkComponent, selector: "ta-link", inputs: ["state", "underline", "bold", "size", "icon"], outputs: ["action"] }, { kind: "component", type: ButtonComponent, selector: "ta-button", inputs: ["state", "type", "size", "icon", "options", "stopPropagationActivation"], outputs: ["action"] }, { kind: "pipe", type: TranslatePipe, name: "translate" }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.14", ngImport: i0, type: InputTranslationComponent, decorators: [{
            type: Component,
            args: [{ selector: 'ta-input-translation', standalone: true, imports: [
                        NgIf,
                        NgFor,
                        NgClass,
                        NgTemplateOutlet,
                        FontIconComponent,
                        MatMenuModule,
                        TitleComponent,
                        LinkComponent,
                        ButtonComponent,
                        TranslatePipe,
                    ], template: "<div class=\"translation-container\">\n  @if (this.input.label) {\n    <ta-title [level]=\"3\" [isBold]=\"true\">{{ this.input.label | translate }}</ta-title>\n  }\n  <div class=\"flex-row align-center g-space-md\">\n    @if (this.cultureMenu) {\n      cultureMenu\n      <!-- <ta-toggle-navigation\n      [menu]=\"this.cultureMenu\"\n      container=\"tab\"\n    ></ta-toggle-navigation> -->\n    }\n    <ta-button size=\"small\" [matMenuTriggerFor]=\"menu\" [stopPropagationActivation]=\"false\">+</ta-button>\n  </div>\n\n  <div class=\"pt-space-md\">\n    @for (input of this.getInputs(this.currentCulture); track input) {\n      @if (input) {\n        <div [ngClass]=\"input.class\">\n          <ng-container\n            [ngTemplateOutlet]=\"this.inputsTemplate()\"\n            [ngTemplateOutletContext]=\"{\n              input: input,\n            }\"\n          ></ng-container>\n        </div>\n      }\n    }\n  </div>\n</div>\n\n<mat-menu #menu=\"matMenu\">\n  @for (culture of this.cultureList; track culture) {\n    <div>\n      <div class=\"flex-row g-space-sm p-space-sm\">\n        @if (this.hasKey(culture.name)) {\n          <ta-font-icon name=\"check-line\" class=\"checked\"></ta-font-icon>\n          <ta-link (action)=\"this.remove(culture.name)\">{{ culture.name }}</ta-link>\n        } @else {\n          <ta-font-icon name=\"check-line\"></ta-font-icon>\n          <ta-link (action)=\"this.add(culture.name)\">{{ culture.name }}</ta-link>\n        }\n      </div>\n    </div>\n  }\n</mat-menu>\n", styles: [".checked{color:var(--ta-semantic-token-success)}.translation-container{padding:var(--ta-space-md);border-radius:var(--ta-radius-rounded);border:1px solid var(--ta-border-secondary)}\n"] }]
        }], ctorParameters: () => [] });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJhbnNsYXRpb24uY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vc3JjL2xpYi9jb21wb25lbnRzL2lucHV0L3RyYW5zbGF0aW9uL3RyYW5zbGF0aW9uLmNvbXBvbmVudC50cyIsIi4uLy4uLy4uLy4uLy4uLy4uL3NyYy9saWIvY29tcG9uZW50cy9pbnB1dC90cmFuc2xhdGlvbi90cmFuc2xhdGlvbi5jb21wb25lbnQuaHRtbCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsT0FBTyxFQUFFLEtBQUssRUFBRSxJQUFJLEVBQUUsZ0JBQWdCLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQztBQUN6RSxPQUFPLEVBQUUsU0FBUyxFQUF1QixLQUFLLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDdEUsT0FBTyxFQUFFLGFBQWEsRUFBRSxNQUFNLHdCQUF3QixDQUFDO0FBR3ZELE9BQU8sRUFBRSxpQkFBaUIsRUFBRSxNQUFNLFdBQVcsQ0FBQztBQUM5QyxPQUFPLEVBQUUsSUFBSSxFQUFFLFFBQVEsRUFBRSxNQUFNLFVBQVUsQ0FBQztBQUMxQyxPQUFPLEVBQUUsYUFBYSxFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFDaEQsT0FBTyxFQUFFLGVBQWUsRUFBRSxhQUFhLEVBQUUsY0FBYyxFQUFFLE1BQU0sUUFBUSxDQUFDO0FBQ3hFLE9BQU8sRUFBRSxPQUFPLEVBQUUsZUFBZSxFQUFFLFdBQVcsRUFBRSxNQUFNLFdBQVcsQ0FBQzs7O0FBb0JsRSxNQUFNLE9BQU8seUJBQTBCLFNBQVEsZUFBZTtJQUk1RCxvQ0FBb0M7SUFDcEMsSUFBSSxLQUFLO1FBQ1AsT0FBTyxJQUFJLENBQUMsVUFBVSxFQUFFLENBQUM7SUFDM0IsQ0FBQztJQU9EO1FBQ0UsS0FBSyxFQUFFLENBQUM7UUFkVixlQUFVLEdBQUcsS0FBSyxDQUFDLFFBQVEsQ0FBbUIsRUFBRSxLQUFLLEVBQUUsT0FBTyxFQUFFLENBQUMsQ0FBQztRQUNsRSxtQkFBYyxHQUFHLEtBQUssQ0FBQyxRQUFRLEVBQW9CLENBQUM7UUFPN0MsZ0JBQVcsR0FBRyxXQUFXLENBQUMsT0FBTyxFQUFFLElBQUksQ0FBQyxDQUFDO1FBQ3pDLGdCQUFXLEdBQWdCLElBQUksQ0FBQztRQUVoQyxtQkFBYyxHQUFXLE9BQU8sQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLENBQUM7SUFJdkQsQ0FBQztJQUVELFFBQVE7UUFDTixJQUFJLENBQUMscUJBQXFCLENBQ3hCLElBQUksQ0FBQyxLQUFLLENBQUMsWUFBWSxDQUFDLFNBQVMsQ0FBQztZQUNoQyxJQUFJLEVBQUUsR0FBRyxFQUFFLENBQUMsSUFBSSxDQUFDLFdBQVcsRUFBRTtTQUMvQixDQUFDLENBQ0gsQ0FBQztRQUNGLElBQUksQ0FBQyxXQUFXLEVBQUUsQ0FBQztJQUNyQixDQUFDO0lBRU0sZUFBZSxDQUFDLE9BQWU7UUFDcEMsSUFBSSxDQUFDLGNBQWMsR0FBRyxPQUFPLENBQUM7SUFDaEMsQ0FBQztJQUVNLEdBQUcsQ0FBQyxPQUFlO1FBQ3hCLElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQyxDQUFDO1FBQ3hCLElBQUksQ0FBQyxlQUFlLENBQUMsT0FBTyxDQUFDLENBQUM7SUFDaEMsQ0FBQztJQUVNLE1BQU0sQ0FBQyxPQUFlO1FBQzNCLElBQUksQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxDQUFDO0lBQzdCLENBQUM7SUFFTSxNQUFNLENBQUMsT0FBZTtRQUMzQixPQUFPLElBQUksQ0FBQyxPQUFPLEVBQUUsQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDLENBQUM7SUFDMUMsQ0FBQztJQUNNLE9BQU87UUFDWixPQUFPLE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxXQUFXLENBQUMsQ0FBQztJQUM3QyxDQUFDO0lBRU0sU0FBUyxDQUFDLE9BQWU7UUFDOUIsT0FBTyxJQUFJLENBQUMsS0FBSyxDQUFDLFdBQVcsQ0FBQyxPQUFPLENBQUMsQ0FBQztJQUN6QyxDQUFDO0lBRU0sU0FBUyxDQUFDLENBQVMsRUFBRSxHQUFXO1FBQ3JDLE9BQU8sR0FBRyxDQUFDO0lBQ2IsQ0FBQztJQUVNLGNBQWMsQ0FBQyxDQUFTLEVBQUUsS0FBcUI7UUFDcEQsT0FBTyxLQUFLLENBQUMsR0FBRyxDQUFDO0lBQ25CLENBQUM7SUFFTyxXQUFXO1FBQ2pCLElBQUksQ0FBQyxXQUFXLEdBQUcsSUFBSSxJQUFJLENBQUM7WUFDMUIsUUFBUSxFQUFFLElBQUksQ0FBQyxPQUFPLEVBQUUsQ0FBQyxHQUFHLENBQzFCLEdBQUcsQ0FBQyxFQUFFLENBQ0osSUFBSSxRQUFRLENBQUM7Z0JBQ1gsR0FBRyxFQUFFLEdBQUc7Z0JBQ1IsS0FBSyxFQUFFLEdBQUc7Z0JBQ1YsS0FBSyxFQUFFLENBQUM7Z0JBQ1IsV0FBVyxFQUFFLElBQUksQ0FBQyxjQUFjLEtBQUssR0FBRztnQkFDeEMsUUFBUSxFQUFFLEdBQUcsRUFBRSxDQUFDLElBQUksQ0FBQyxlQUFlLENBQUMsR0FBRyxDQUFDO2FBQzFDLENBQUMsQ0FDTDtZQUNELFNBQVMsRUFBRSxZQUFZO1NBQ3hCLENBQUMsQ0FBQztJQUNMLENBQUM7K0dBekVVLHlCQUF5QjttR0FBekIseUJBQXlCLHNZQzdCdEMsby9DQThDQSxpUEQzQkksT0FBTyxvRkFDUCxnQkFBZ0Isb0pBQ2hCLGlCQUFpQixrRkFDakIsYUFBYSwwbUJBQ2IsY0FBYyxxR0FDZCxhQUFhLGlJQUNiLGVBQWUseUpBQ2YsYUFBYTs7NEZBR0oseUJBQXlCO2tCQWxCckMsU0FBUzsrQkFDRSxzQkFBc0IsY0FHcEIsSUFBSSxXQUNQO3dCQUNQLElBQUk7d0JBQ0osS0FBSzt3QkFDTCxPQUFPO3dCQUNQLGdCQUFnQjt3QkFDaEIsaUJBQWlCO3dCQUNqQixhQUFhO3dCQUNiLGNBQWM7d0JBQ2QsYUFBYTt3QkFDYixlQUFlO3dCQUNmLGFBQWE7cUJBQ2QiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBOZ0NsYXNzLCBOZ0ZvciwgTmdJZiwgTmdUZW1wbGF0ZU91dGxldCB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBDb21wb25lbnQsIE9uSW5pdCwgVGVtcGxhdGVSZWYsIGlucHV0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBNYXRNZW51TW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvbWF0ZXJpYWwvbWVudSc7XG5cbmltcG9ydCB7IElucHV0QmFzZSwgSW5wdXRUcmFuc2xhdGlvbiB9IGZyb20gJ0B0YS9mb3JtLW1vZGVsJztcbmltcG9ydCB7IEZvbnRJY29uQ29tcG9uZW50IH0gZnJvbSAnQHRhL2ljb25zJztcbmltcG9ydCB7IE1lbnUsIE1lbnVCYXNlIH0gZnJvbSAnQHRhL21lbnUnO1xuaW1wb3J0IHsgVHJhbnNsYXRlUGlwZSB9IGZyb20gJ0B0YS90cmFuc2xhdGlvbic7XG5pbXBvcnQgeyBCdXR0b25Db21wb25lbnQsIExpbmtDb21wb25lbnQsIFRpdGxlQ29tcG9uZW50IH0gZnJvbSAnQHRhL3VpJztcbmltcG9ydCB7IEN1bHR1cmUsIFRhQmFzZUNvbXBvbmVudCwgZXh0cmFjdEVudW0gfSBmcm9tICdAdGEvdXRpbHMnO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICd0YS1pbnB1dC10cmFuc2xhdGlvbicsXG4gIHRlbXBsYXRlVXJsOiAnLi90cmFuc2xhdGlvbi5jb21wb25lbnQuaHRtbCcsXG4gIHN0eWxlVXJsczogWycuL3RyYW5zbGF0aW9uLmNvbXBvbmVudC5zY3NzJ10sXG4gIHN0YW5kYWxvbmU6IHRydWUsXG4gIGltcG9ydHM6IFtcbiAgICBOZ0lmLFxuICAgIE5nRm9yLFxuICAgIE5nQ2xhc3MsXG4gICAgTmdUZW1wbGF0ZU91dGxldCxcbiAgICBGb250SWNvbkNvbXBvbmVudCxcbiAgICBNYXRNZW51TW9kdWxlLFxuICAgIFRpdGxlQ29tcG9uZW50LFxuICAgIExpbmtDb21wb25lbnQsXG4gICAgQnV0dG9uQ29tcG9uZW50LFxuICAgIFRyYW5zbGF0ZVBpcGUsXG4gIF0sXG59KVxuZXhwb3J0IGNsYXNzIElucHV0VHJhbnNsYXRpb25Db21wb25lbnQgZXh0ZW5kcyBUYUJhc2VDb21wb25lbnQgaW1wbGVtZW50cyBPbkluaXQge1xuICBpbnB1dE1vZGVsID0gaW5wdXQucmVxdWlyZWQ8SW5wdXRUcmFuc2xhdGlvbj4oeyBhbGlhczogJ2lucHV0JyB9KTtcbiAgaW5wdXRzVGVtcGxhdGUgPSBpbnB1dC5yZXF1aXJlZDxUZW1wbGF0ZVJlZjxhbnk+PigpO1xuXG4gIC8vIEdldHRlciBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eVxuICBnZXQgaW5wdXQoKTogSW5wdXRUcmFuc2xhdGlvbiB7XG4gICAgcmV0dXJuIHRoaXMuaW5wdXRNb2RlbCgpO1xuICB9XG5cbiAgcHVibGljIGN1bHR1cmVMaXN0ID0gZXh0cmFjdEVudW0oQ3VsdHVyZSwgdHJ1ZSk7XG4gIHB1YmxpYyBjdWx0dXJlTWVudTogTWVudSB8IG51bGwgPSBudWxsO1xuXG4gIHB1YmxpYyBjdXJyZW50Q3VsdHVyZTogc3RyaW5nID0gQ3VsdHVyZVtDdWx0dXJlLkZSX0JFXTtcblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuICB9XG5cbiAgbmdPbkluaXQoKSB7XG4gICAgdGhpcy5fcmVnaXN0ZXJTdWJzY3JpcHRpb24oXG4gICAgICB0aGlzLmlucHV0Lmxpc3RDaGFuZ2VkJC5zdWJzY3JpYmUoe1xuICAgICAgICBuZXh0OiAoKSA9PiB0aGlzLl9yZW5kZXJNZW51KCksXG4gICAgICB9KVxuICAgICk7XG4gICAgdGhpcy5fcmVuZGVyTWVudSgpO1xuICB9XG5cbiAgcHVibGljIGNoYW5nZVNlbGVjdGlvbihjdWx0dXJlOiBzdHJpbmcpIHtcbiAgICB0aGlzLmN1cnJlbnRDdWx0dXJlID0gY3VsdHVyZTtcbiAgfVxuXG4gIHB1YmxpYyBhZGQoY3VsdHVyZTogc3RyaW5nKSB7XG4gICAgdGhpcy5pbnB1dC5hZGQoY3VsdHVyZSk7XG4gICAgdGhpcy5jaGFuZ2VTZWxlY3Rpb24oY3VsdHVyZSk7XG4gIH1cblxuICBwdWJsaWMgcmVtb3ZlKGN1bHR1cmU6IHN0cmluZykge1xuICAgIHRoaXMuaW5wdXQucmVtb3ZlKGN1bHR1cmUpO1xuICB9XG5cbiAgcHVibGljIGhhc0tleShjdWx0dXJlOiBzdHJpbmcpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRLZXlzKCkuaW5jbHVkZXMoY3VsdHVyZSk7XG4gIH1cbiAgcHVibGljIGdldEtleXMoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuaW5wdXQuaW5wdXRzR3JvdXApO1xuICB9XG5cbiAgcHVibGljIGdldElucHV0cyhjdWx0dXJlOiBzdHJpbmcpIHtcbiAgICByZXR1cm4gdGhpcy5pbnB1dC5pbnB1dHNHcm91cFtjdWx0dXJlXTtcbiAgfVxuXG4gIHB1YmxpYyB0cmFja0J5Rm4oXzogbnVtYmVyLCBrZXk6IHN0cmluZykge1xuICAgIHJldHVybiBrZXk7XG4gIH1cblxuICBwdWJsaWMgdHJhY2tJbnB1dEJ5Rm4oXzogbnVtYmVyLCBpbnB1dDogSW5wdXRCYXNlPGFueT4pIHtcbiAgICByZXR1cm4gaW5wdXQua2V5O1xuICB9XG5cbiAgcHJpdmF0ZSBfcmVuZGVyTWVudSgpIHtcbiAgICB0aGlzLmN1bHR1cmVNZW51ID0gbmV3IE1lbnUoe1xuICAgICAgZWxlbWVudHM6IHRoaXMuZ2V0S2V5cygpLm1hcChcbiAgICAgICAgY3VsID0+XG4gICAgICAgICAgbmV3IE1lbnVCYXNlKHtcbiAgICAgICAgICAgIGtleTogY3VsLFxuICAgICAgICAgICAgbGFiZWw6IGN1bCxcbiAgICAgICAgICAgIG9yZGVyOiAxLFxuICAgICAgICAgICAgZGVmYXVsdE9wZW46IHRoaXMuY3VycmVudEN1bHR1cmUgPT09IGN1bCxcbiAgICAgICAgICAgIGNhbGxiYWNrOiAoKSA9PiB0aGlzLmNoYW5nZVNlbGVjdGlvbihjdWwpLFxuICAgICAgICAgIH0pXG4gICAgICApLFxuICAgICAgZGlyZWN0aW9uOiAnaG9yaXpvbnRhbCcsXG4gICAgfSk7XG4gIH1cbn1cbiIsIjxkaXYgY2xhc3M9XCJ0cmFuc2xhdGlvbi1jb250YWluZXJcIj5cbiAgQGlmICh0aGlzLmlucHV0LmxhYmVsKSB7XG4gICAgPHRhLXRpdGxlIFtsZXZlbF09XCIzXCIgW2lzQm9sZF09XCJ0cnVlXCI+e3sgdGhpcy5pbnB1dC5sYWJlbCB8IHRyYW5zbGF0ZSB9fTwvdGEtdGl0bGU+XG4gIH1cbiAgPGRpdiBjbGFzcz1cImZsZXgtcm93IGFsaWduLWNlbnRlciBnLXNwYWNlLW1kXCI+XG4gICAgQGlmICh0aGlzLmN1bHR1cmVNZW51KSB7XG4gICAgICBjdWx0dXJlTWVudVxuICAgICAgPCEtLSA8dGEtdG9nZ2xlLW5hdmlnYXRpb25cbiAgICAgIFttZW51XT1cInRoaXMuY3VsdHVyZU1lbnVcIlxuICAgICAgY29udGFpbmVyPVwidGFiXCJcbiAgICA+PC90YS10b2dnbGUtbmF2aWdhdGlvbj4gLS0+XG4gICAgfVxuICAgIDx0YS1idXR0b24gc2l6ZT1cInNtYWxsXCIgW21hdE1lbnVUcmlnZ2VyRm9yXT1cIm1lbnVcIiBbc3RvcFByb3BhZ2F0aW9uQWN0aXZhdGlvbl09XCJmYWxzZVwiPis8L3RhLWJ1dHRvbj5cbiAgPC9kaXY+XG5cbiAgPGRpdiBjbGFzcz1cInB0LXNwYWNlLW1kXCI+XG4gICAgQGZvciAoaW5wdXQgb2YgdGhpcy5nZXRJbnB1dHModGhpcy5jdXJyZW50Q3VsdHVyZSk7IHRyYWNrIGlucHV0KSB7XG4gICAgICBAaWYgKGlucHV0KSB7XG4gICAgICAgIDxkaXYgW25nQ2xhc3NdPVwiaW5wdXQuY2xhc3NcIj5cbiAgICAgICAgICA8bmctY29udGFpbmVyXG4gICAgICAgICAgICBbbmdUZW1wbGF0ZU91dGxldF09XCJ0aGlzLmlucHV0c1RlbXBsYXRlKClcIlxuICAgICAgICAgICAgW25nVGVtcGxhdGVPdXRsZXRDb250ZXh0XT1cIntcbiAgICAgICAgICAgICAgaW5wdXQ6IGlucHV0LFxuICAgICAgICAgICAgfVwiXG4gICAgICAgICAgPjwvbmctY29udGFpbmVyPlxuICAgICAgICA8L2Rpdj5cbiAgICAgIH1cbiAgICB9XG4gIDwvZGl2PlxuPC9kaXY+XG5cbjxtYXQtbWVudSAjbWVudT1cIm1hdE1lbnVcIj5cbiAgQGZvciAoY3VsdHVyZSBvZiB0aGlzLmN1bHR1cmVMaXN0OyB0cmFjayBjdWx0dXJlKSB7XG4gICAgPGRpdj5cbiAgICAgIDxkaXYgY2xhc3M9XCJmbGV4LXJvdyBnLXNwYWNlLXNtIHAtc3BhY2Utc21cIj5cbiAgICAgICAgQGlmICh0aGlzLmhhc0tleShjdWx0dXJlLm5hbWUpKSB7XG4gICAgICAgICAgPHRhLWZvbnQtaWNvbiBuYW1lPVwiY2hlY2stbGluZVwiIGNsYXNzPVwiY2hlY2tlZFwiPjwvdGEtZm9udC1pY29uPlxuICAgICAgICAgIDx0YS1saW5rIChhY3Rpb24pPVwidGhpcy5yZW1vdmUoY3VsdHVyZS5uYW1lKVwiPnt7IGN1bHR1cmUubmFtZSB9fTwvdGEtbGluaz5cbiAgICAgICAgfSBAZWxzZSB7XG4gICAgICAgICAgPHRhLWZvbnQtaWNvbiBuYW1lPVwiY2hlY2stbGluZVwiPjwvdGEtZm9udC1pY29uPlxuICAgICAgICAgIDx0YS1saW5rIChhY3Rpb24pPVwidGhpcy5hZGQoY3VsdHVyZS5uYW1lKVwiPnt7IGN1bHR1cmUubmFtZSB9fTwvdGEtbGluaz5cbiAgICAgICAgfVxuICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG4gIH1cbjwvbWF0LW1lbnU+XG4iXX0=