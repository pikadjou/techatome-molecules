import { NgIf, NgFor, NgClass, NgTemplateOutlet } from '@angular/common';
import { FontIconComponent } from '@ta/icons';
import { Component, Input } from '@angular/core';
import { MatMenuModule } from '@angular/material/menu';
import { Menu, MenuBase, ToggleNavigationComponent } from '@ta/menu';
import { TranslatePipe } from '@ta/translation';
import { TitleComponent, LinkComponent, ButtonComponent } from '@ta/ui';
import { TaBaseComponent, Culture, extractEnum } from '@ta/utils';
import * as i0 from "@angular/core";
import * as i1 from "@angular/material/menu";
export class InputTranslationComponent extends TaBaseComponent {
    constructor() {
        super();
        this.cultureList = extractEnum(Culture, true);
        this.cultureMenu = null;
        this.currentCulture = Culture[Culture.FR_BE];
    }
    ngOnInit() {
        this._registerSubscription(this.input.listChanged$.subscribe({
            next: () => this._renderMenu(),
        }));
        this._renderMenu();
    }
    changeSelection(culture) {
        this.currentCulture = culture;
    }
    add(culture) {
        this.input.add(culture);
        this.changeSelection(culture);
    }
    remove(culture) {
        this.input.remove(culture);
    }
    hasKey(culture) {
        return this.getKeys().includes(culture);
    }
    getKeys() {
        return Object.keys(this.input.inputsGroup);
    }
    getInputs(culture) {
        return this.input.inputsGroup[culture];
    }
    trackByFn(_, key) {
        return key;
    }
    trackInputByFn(_, input) {
        return input.key;
    }
    _renderMenu() {
        this.cultureMenu = new Menu({
            elements: this.getKeys().map(cul => new MenuBase({
                key: cul,
                label: cul,
                order: 1,
                defaultOpen: this.currentCulture === cul,
                callback: () => this.changeSelection(cul),
            })),
            direction: 'horizontal',
        });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: InputTranslationComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "18.2.13", type: InputTranslationComponent, isStandalone: true, selector: "ta-input-translation", inputs: { input: "input", inputsTemplate: "inputsTemplate" }, usesInheritance: true, ngImport: i0, template: "<div class=\"translation-container\">\n  @if (this.input.label) {\n    <ta-title [level]=\"3\" [isBold]=\"true\">{{ this.input.label | translate }}</ta-title>\n  }\n  <div class=\"flex-row align-center g-space-md\">\n    @if (this.cultureMenu) {\n      <ta-toggle-navigation [menu]=\"this.cultureMenu\" container=\"tab\"></ta-toggle-navigation>\n    }\n    <ta-button size=\"small\" [matMenuTriggerFor]=\"menu\" [stopPropagationActivation]=\"false\">+</ta-button>\n  </div>\n\n  <div class=\"pt-space-md\">\n    @for (input of this.getInputs(this.currentCulture); track input) {\n      @if (input) {\n        <div [ngClass]=\"input.class\">\n          <ng-container\n            [ngTemplateOutlet]=\"this.inputsTemplate\"\n            [ngTemplateOutletContext]=\"{\n              input: input,\n            }\"\n          >\n          </ng-container>\n        </div>\n      }\n    }\n  </div>\n</div>\n\n<mat-menu #menu=\"matMenu\">\n  @for (culture of this.cultureList; track culture) {\n    <div>\n      <div class=\"flex-row g-space-sm p-space-sm\">\n        @if (this.hasKey(culture.name)) {\n          <ta-font-icon name=\"check-line\" class=\"checked\"></ta-font-icon>\n          <ta-link (action)=\"this.remove(culture.name)\">{{ culture.name }}</ta-link>\n        } @else {\n          <ta-font-icon name=\"check-line\"> </ta-font-icon>\n          <ta-link (action)=\"this.add(culture.name)\">{{ culture.name }}</ta-link>\n        }\n      </div>\n    </div>\n  }\n</mat-menu>\n", styles: [".checked{color:var(--ta-semantic-token-success)}.translation-container{padding:var(--ta-space-md);border-radius:var(--ta-radius-rounded);border:1px solid var(--ta-border-secondary)}\n"], dependencies: [{ kind: "directive", type: NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }, { kind: "component", type: FontIconComponent, selector: "ta-font-icon", inputs: ["name", "type"] }, { kind: "ngmodule", type: MatMenuModule }, { kind: "component", type: i1.MatMenu, selector: "mat-menu", inputs: ["backdropClass", "aria-label", "aria-labelledby", "aria-describedby", "xPosition", "yPosition", "overlapTrigger", "hasBackdrop", "class", "classList"], outputs: ["closed", "close"], exportAs: ["matMenu"] }, { kind: "directive", type: i1.MatMenuTrigger, selector: "[mat-menu-trigger-for], [matMenuTriggerFor]", inputs: ["mat-menu-trigger-for", "matMenuTriggerFor", "matMenuTriggerData", "matMenuTriggerRestoreFocus"], outputs: ["menuOpened", "onMenuOpen", "menuClosed", "onMenuClose"], exportAs: ["matMenuTrigger"] }, { kind: "component", type: ToggleNavigationComponent, selector: "ta-toggle-navigation", inputs: ["menu", "container"] }, { kind: "component", type: TitleComponent, selector: "ta-title", inputs: ["level", "isTheme", "isBold", "icon"] }, { kind: "component", type: LinkComponent, selector: "ta-link", inputs: ["state", "underline", "bold", "size", "icon"], outputs: ["action"] }, { kind: "component", type: ButtonComponent, selector: "ta-button", inputs: ["state", "type", "size", "icon", "options", "stopPropagationActivation"], outputs: ["action"] }, { kind: "pipe", type: TranslatePipe, name: "translate" }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: InputTranslationComponent, decorators: [{
            type: Component,
            args: [{ selector: 'ta-input-translation', standalone: true, imports: [NgIf, NgFor, NgClass, NgTemplateOutlet, FontIconComponent, MatMenuModule, ToggleNavigationComponent, TitleComponent, LinkComponent, ButtonComponent, TranslatePipe], template: "<div class=\"translation-container\">\n  @if (this.input.label) {\n    <ta-title [level]=\"3\" [isBold]=\"true\">{{ this.input.label | translate }}</ta-title>\n  }\n  <div class=\"flex-row align-center g-space-md\">\n    @if (this.cultureMenu) {\n      <ta-toggle-navigation [menu]=\"this.cultureMenu\" container=\"tab\"></ta-toggle-navigation>\n    }\n    <ta-button size=\"small\" [matMenuTriggerFor]=\"menu\" [stopPropagationActivation]=\"false\">+</ta-button>\n  </div>\n\n  <div class=\"pt-space-md\">\n    @for (input of this.getInputs(this.currentCulture); track input) {\n      @if (input) {\n        <div [ngClass]=\"input.class\">\n          <ng-container\n            [ngTemplateOutlet]=\"this.inputsTemplate\"\n            [ngTemplateOutletContext]=\"{\n              input: input,\n            }\"\n          >\n          </ng-container>\n        </div>\n      }\n    }\n  </div>\n</div>\n\n<mat-menu #menu=\"matMenu\">\n  @for (culture of this.cultureList; track culture) {\n    <div>\n      <div class=\"flex-row g-space-sm p-space-sm\">\n        @if (this.hasKey(culture.name)) {\n          <ta-font-icon name=\"check-line\" class=\"checked\"></ta-font-icon>\n          <ta-link (action)=\"this.remove(culture.name)\">{{ culture.name }}</ta-link>\n        } @else {\n          <ta-font-icon name=\"check-line\"> </ta-font-icon>\n          <ta-link (action)=\"this.add(culture.name)\">{{ culture.name }}</ta-link>\n        }\n      </div>\n    </div>\n  }\n</mat-menu>\n", styles: [".checked{color:var(--ta-semantic-token-success)}.translation-container{padding:var(--ta-space-md);border-radius:var(--ta-radius-rounded);border:1px solid var(--ta-border-secondary)}\n"] }]
        }], ctorParameters: () => [], propDecorators: { input: [{
                type: Input
            }], inputsTemplate: [{
                type: Input
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJhbnNsYXRpb24uY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vc3JjL2xpYi9jb21wb25lbnRzL2lucHV0L3RyYW5zbGF0aW9uL3RyYW5zbGF0aW9uLmNvbXBvbmVudC50cyIsIi4uLy4uLy4uLy4uLy4uLy4uL3NyYy9saWIvY29tcG9uZW50cy9pbnB1dC90cmFuc2xhdGlvbi90cmFuc2xhdGlvbi5jb21wb25lbnQuaHRtbCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsSUFBSSxFQUFFLEtBQUssRUFBRSxPQUFPLEVBQUUsZ0JBQWdCLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQztBQUN6RSxPQUFPLEVBQUUsaUJBQWlCLEVBQUUsTUFBTSxXQUFXLENBQUM7QUFDOUMsT0FBTyxFQUFFLFNBQVMsRUFBRSxLQUFLLEVBQXVCLE1BQU0sZUFBZSxDQUFDO0FBQ3RFLE9BQU8sRUFBRSxhQUFhLEVBQUUsTUFBTSx3QkFBd0IsQ0FBQztBQUd2RCxPQUFPLEVBQUUsSUFBSSxFQUFFLFFBQVEsRUFBRSx5QkFBeUIsRUFBRSxNQUFNLFVBQVUsQ0FBQztBQUNyRSxPQUFPLEVBQUUsYUFBYSxFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFDaEQsT0FBTyxFQUFFLGNBQWMsRUFBRSxhQUFhLEVBQUUsZUFBZSxFQUFFLE1BQU0sUUFBUSxDQUFDO0FBQ3hFLE9BQU8sRUFBRSxlQUFlLEVBQUUsT0FBTyxFQUFFLFdBQVcsRUFBRSxNQUFNLFdBQVcsQ0FBQzs7O0FBU2xFLE1BQU0sT0FBTyx5QkFBMEIsU0FBUSxlQUFlO0lBVzVEO1FBQ0UsS0FBSyxFQUFFLENBQUM7UUFOSCxnQkFBVyxHQUFHLFdBQVcsQ0FBQyxPQUFPLEVBQUUsSUFBSSxDQUFDLENBQUM7UUFDekMsZ0JBQVcsR0FBZ0IsSUFBSSxDQUFDO1FBRWhDLG1CQUFjLEdBQVcsT0FBTyxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUl2RCxDQUFDO0lBRUQsUUFBUTtRQUNOLElBQUksQ0FBQyxxQkFBcUIsQ0FDeEIsSUFBSSxDQUFDLEtBQUssQ0FBQyxZQUFZLENBQUMsU0FBUyxDQUFDO1lBQ2hDLElBQUksRUFBRSxHQUFHLEVBQUUsQ0FBQyxJQUFJLENBQUMsV0FBVyxFQUFFO1NBQy9CLENBQUMsQ0FDSCxDQUFDO1FBQ0YsSUFBSSxDQUFDLFdBQVcsRUFBRSxDQUFDO0lBQ3JCLENBQUM7SUFFTSxlQUFlLENBQUMsT0FBZTtRQUNwQyxJQUFJLENBQUMsY0FBYyxHQUFHLE9BQU8sQ0FBQztJQUNoQyxDQUFDO0lBRU0sR0FBRyxDQUFDLE9BQWU7UUFDeEIsSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFDLENBQUM7UUFDeEIsSUFBSSxDQUFDLGVBQWUsQ0FBQyxPQUFPLENBQUMsQ0FBQztJQUNoQyxDQUFDO0lBRU0sTUFBTSxDQUFDLE9BQWU7UUFDM0IsSUFBSSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLENBQUM7SUFDN0IsQ0FBQztJQUVNLE1BQU0sQ0FBQyxPQUFlO1FBQzNCLE9BQU8sSUFBSSxDQUFDLE9BQU8sRUFBRSxDQUFDLFFBQVEsQ0FBQyxPQUFPLENBQUMsQ0FBQztJQUMxQyxDQUFDO0lBQ00sT0FBTztRQUNaLE9BQU8sTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLFdBQVcsQ0FBQyxDQUFDO0lBQzdDLENBQUM7SUFFTSxTQUFTLENBQUMsT0FBZTtRQUM5QixPQUFPLElBQUksQ0FBQyxLQUFLLENBQUMsV0FBVyxDQUFDLE9BQU8sQ0FBQyxDQUFDO0lBQ3pDLENBQUM7SUFFTSxTQUFTLENBQUMsQ0FBUyxFQUFFLEdBQVc7UUFDckMsT0FBTyxHQUFHLENBQUM7SUFDYixDQUFDO0lBRU0sY0FBYyxDQUFDLENBQVMsRUFBRSxLQUFxQjtRQUNwRCxPQUFPLEtBQUssQ0FBQyxHQUFHLENBQUM7SUFDbkIsQ0FBQztJQUVPLFdBQVc7UUFDakIsSUFBSSxDQUFDLFdBQVcsR0FBRyxJQUFJLElBQUksQ0FBQztZQUMxQixRQUFRLEVBQUUsSUFBSSxDQUFDLE9BQU8sRUFBRSxDQUFDLEdBQUcsQ0FDMUIsR0FBRyxDQUFDLEVBQUUsQ0FDSixJQUFJLFFBQVEsQ0FBQztnQkFDWCxHQUFHLEVBQUUsR0FBRztnQkFDUixLQUFLLEVBQUUsR0FBRztnQkFDVixLQUFLLEVBQUUsQ0FBQztnQkFDUixXQUFXLEVBQUUsSUFBSSxDQUFDLGNBQWMsS0FBSyxHQUFHO2dCQUN4QyxRQUFRLEVBQUUsR0FBRyxFQUFFLENBQUMsSUFBSSxDQUFDLGVBQWUsQ0FBQyxHQUFHLENBQUM7YUFDMUMsQ0FBQyxDQUNMO1lBQ0QsU0FBUyxFQUFFLFlBQVk7U0FDeEIsQ0FBQyxDQUFDO0lBQ0wsQ0FBQzsrR0F0RVUseUJBQXlCO21HQUF6Qix5QkFBeUIscUtDbEJ0QywrOENBMkNBLGlQRDNCeUIsT0FBTyxvRkFBRSxnQkFBZ0Isb0pBQUUsaUJBQWlCLGtGQUFFLGFBQWEsMG1CQUFFLHlCQUF5QixnR0FBRSxjQUFjLHFHQUFFLGFBQWEsaUlBQUUsZUFBZSx5SkFBRSxhQUFhOzs0RkFFaksseUJBQXlCO2tCQVByQyxTQUFTOytCQUNBLHNCQUFzQixjQUdsQixJQUFJLFdBQ1AsQ0FBQyxJQUFJLEVBQUUsS0FBSyxFQUFFLE9BQU8sRUFBRSxnQkFBZ0IsRUFBRSxpQkFBaUIsRUFBRSxhQUFhLEVBQUUseUJBQXlCLEVBQUUsY0FBYyxFQUFFLGFBQWEsRUFBRSxlQUFlLEVBQUUsYUFBYSxDQUFDO3dEQUk3SyxLQUFLO3NCQURKLEtBQUs7Z0JBR04sY0FBYztzQkFEYixLQUFLIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTmdJZiwgTmdGb3IsIE5nQ2xhc3MsIE5nVGVtcGxhdGVPdXRsZXQgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgRm9udEljb25Db21wb25lbnQgfSBmcm9tICdAdGEvaWNvbnMnO1xuaW1wb3J0IHsgQ29tcG9uZW50LCBJbnB1dCwgT25Jbml0LCBUZW1wbGF0ZVJlZiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgTWF0TWVudU1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL21hdGVyaWFsL21lbnUnO1xuXG5pbXBvcnQgeyBJbnB1dEJhc2UsIElucHV0VHJhbnNsYXRpb24gfSBmcm9tICdAdGEvZm9ybS1tb2RlbCc7XG5pbXBvcnQgeyBNZW51LCBNZW51QmFzZSwgVG9nZ2xlTmF2aWdhdGlvbkNvbXBvbmVudCB9IGZyb20gJ0B0YS9tZW51JztcbmltcG9ydCB7IFRyYW5zbGF0ZVBpcGUgfSBmcm9tICdAdGEvdHJhbnNsYXRpb24nO1xuaW1wb3J0IHsgVGl0bGVDb21wb25lbnQsIExpbmtDb21wb25lbnQsIEJ1dHRvbkNvbXBvbmVudCB9IGZyb20gJ0B0YS91aSc7XG5pbXBvcnQgeyBUYUJhc2VDb21wb25lbnQsIEN1bHR1cmUsIGV4dHJhY3RFbnVtIH0gZnJvbSAnQHRhL3V0aWxzJztcblxuQENvbXBvbmVudCh7XG5zZWxlY3RvcjogJ3RhLWlucHV0LXRyYW5zbGF0aW9uJyxcbiAgdGVtcGxhdGVVcmw6ICcuL3RyYW5zbGF0aW9uLmNvbXBvbmVudC5odG1sJyxcbiAgc3R5bGVVcmxzOiBbJy4vdHJhbnNsYXRpb24uY29tcG9uZW50LnNjc3MnXSxcbiAgc3RhbmRhbG9uZTogdHJ1ZSxcbiAgaW1wb3J0czogW05nSWYsIE5nRm9yLCBOZ0NsYXNzLCBOZ1RlbXBsYXRlT3V0bGV0LCBGb250SWNvbkNvbXBvbmVudCwgTWF0TWVudU1vZHVsZSwgVG9nZ2xlTmF2aWdhdGlvbkNvbXBvbmVudCwgVGl0bGVDb21wb25lbnQsIExpbmtDb21wb25lbnQsIEJ1dHRvbkNvbXBvbmVudCwgVHJhbnNsYXRlUGlwZV0sXG59KVxuZXhwb3J0IGNsYXNzIElucHV0VHJhbnNsYXRpb25Db21wb25lbnQgZXh0ZW5kcyBUYUJhc2VDb21wb25lbnQgaW1wbGVtZW50cyBPbkluaXQge1xuICBASW5wdXQoKVxuICBpbnB1dCE6IElucHV0VHJhbnNsYXRpb247XG4gIEBJbnB1dCgpXG4gIGlucHV0c1RlbXBsYXRlITogVGVtcGxhdGVSZWY8YW55PjtcblxuICBwdWJsaWMgY3VsdHVyZUxpc3QgPSBleHRyYWN0RW51bShDdWx0dXJlLCB0cnVlKTtcbiAgcHVibGljIGN1bHR1cmVNZW51OiBNZW51IHwgbnVsbCA9IG51bGw7XG5cbiAgcHVibGljIGN1cnJlbnRDdWx0dXJlOiBzdHJpbmcgPSBDdWx0dXJlW0N1bHR1cmUuRlJfQkVdO1xuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG4gIH1cblxuICBuZ09uSW5pdCgpIHtcbiAgICB0aGlzLl9yZWdpc3RlclN1YnNjcmlwdGlvbihcbiAgICAgIHRoaXMuaW5wdXQubGlzdENoYW5nZWQkLnN1YnNjcmliZSh7XG4gICAgICAgIG5leHQ6ICgpID0+IHRoaXMuX3JlbmRlck1lbnUoKSxcbiAgICAgIH0pXG4gICAgKTtcbiAgICB0aGlzLl9yZW5kZXJNZW51KCk7XG4gIH1cblxuICBwdWJsaWMgY2hhbmdlU2VsZWN0aW9uKGN1bHR1cmU6IHN0cmluZykge1xuICAgIHRoaXMuY3VycmVudEN1bHR1cmUgPSBjdWx0dXJlO1xuICB9XG5cbiAgcHVibGljIGFkZChjdWx0dXJlOiBzdHJpbmcpIHtcbiAgICB0aGlzLmlucHV0LmFkZChjdWx0dXJlKTtcbiAgICB0aGlzLmNoYW5nZVNlbGVjdGlvbihjdWx0dXJlKTtcbiAgfVxuXG4gIHB1YmxpYyByZW1vdmUoY3VsdHVyZTogc3RyaW5nKSB7XG4gICAgdGhpcy5pbnB1dC5yZW1vdmUoY3VsdHVyZSk7XG4gIH1cblxuICBwdWJsaWMgaGFzS2V5KGN1bHR1cmU6IHN0cmluZykge1xuICAgIHJldHVybiB0aGlzLmdldEtleXMoKS5pbmNsdWRlcyhjdWx0dXJlKTtcbiAgfVxuICBwdWJsaWMgZ2V0S2V5cygpIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5pbnB1dC5pbnB1dHNHcm91cCk7XG4gIH1cblxuICBwdWJsaWMgZ2V0SW5wdXRzKGN1bHR1cmU6IHN0cmluZykge1xuICAgIHJldHVybiB0aGlzLmlucHV0LmlucHV0c0dyb3VwW2N1bHR1cmVdO1xuICB9XG5cbiAgcHVibGljIHRyYWNrQnlGbihfOiBudW1iZXIsIGtleTogc3RyaW5nKSB7XG4gICAgcmV0dXJuIGtleTtcbiAgfVxuXG4gIHB1YmxpYyB0cmFja0lucHV0QnlGbihfOiBudW1iZXIsIGlucHV0OiBJbnB1dEJhc2U8YW55Pikge1xuICAgIHJldHVybiBpbnB1dC5rZXk7XG4gIH1cblxuICBwcml2YXRlIF9yZW5kZXJNZW51KCkge1xuICAgIHRoaXMuY3VsdHVyZU1lbnUgPSBuZXcgTWVudSh7XG4gICAgICBlbGVtZW50czogdGhpcy5nZXRLZXlzKCkubWFwKFxuICAgICAgICBjdWwgPT5cbiAgICAgICAgICBuZXcgTWVudUJhc2Uoe1xuICAgICAgICAgICAga2V5OiBjdWwsXG4gICAgICAgICAgICBsYWJlbDogY3VsLFxuICAgICAgICAgICAgb3JkZXI6IDEsXG4gICAgICAgICAgICBkZWZhdWx0T3BlbjogdGhpcy5jdXJyZW50Q3VsdHVyZSA9PT0gY3VsLFxuICAgICAgICAgICAgY2FsbGJhY2s6ICgpID0+IHRoaXMuY2hhbmdlU2VsZWN0aW9uKGN1bCksXG4gICAgICAgICAgfSlcbiAgICAgICksXG4gICAgICBkaXJlY3Rpb246ICdob3Jpem9udGFsJyxcbiAgICB9KTtcbiAgfVxufVxuIiwiPGRpdiBjbGFzcz1cInRyYW5zbGF0aW9uLWNvbnRhaW5lclwiPlxuICBAaWYgKHRoaXMuaW5wdXQubGFiZWwpIHtcbiAgICA8dGEtdGl0bGUgW2xldmVsXT1cIjNcIiBbaXNCb2xkXT1cInRydWVcIj57eyB0aGlzLmlucHV0LmxhYmVsIHwgdHJhbnNsYXRlIH19PC90YS10aXRsZT5cbiAgfVxuICA8ZGl2IGNsYXNzPVwiZmxleC1yb3cgYWxpZ24tY2VudGVyIGctc3BhY2UtbWRcIj5cbiAgICBAaWYgKHRoaXMuY3VsdHVyZU1lbnUpIHtcbiAgICAgIDx0YS10b2dnbGUtbmF2aWdhdGlvbiBbbWVudV09XCJ0aGlzLmN1bHR1cmVNZW51XCIgY29udGFpbmVyPVwidGFiXCI+PC90YS10b2dnbGUtbmF2aWdhdGlvbj5cbiAgICB9XG4gICAgPHRhLWJ1dHRvbiBzaXplPVwic21hbGxcIiBbbWF0TWVudVRyaWdnZXJGb3JdPVwibWVudVwiIFtzdG9wUHJvcGFnYXRpb25BY3RpdmF0aW9uXT1cImZhbHNlXCI+KzwvdGEtYnV0dG9uPlxuICA8L2Rpdj5cblxuICA8ZGl2IGNsYXNzPVwicHQtc3BhY2UtbWRcIj5cbiAgICBAZm9yIChpbnB1dCBvZiB0aGlzLmdldElucHV0cyh0aGlzLmN1cnJlbnRDdWx0dXJlKTsgdHJhY2sgaW5wdXQpIHtcbiAgICAgIEBpZiAoaW5wdXQpIHtcbiAgICAgICAgPGRpdiBbbmdDbGFzc109XCJpbnB1dC5jbGFzc1wiPlxuICAgICAgICAgIDxuZy1jb250YWluZXJcbiAgICAgICAgICAgIFtuZ1RlbXBsYXRlT3V0bGV0XT1cInRoaXMuaW5wdXRzVGVtcGxhdGVcIlxuICAgICAgICAgICAgW25nVGVtcGxhdGVPdXRsZXRDb250ZXh0XT1cIntcbiAgICAgICAgICAgICAgaW5wdXQ6IGlucHV0LFxuICAgICAgICAgICAgfVwiXG4gICAgICAgICAgPlxuICAgICAgICAgIDwvbmctY29udGFpbmVyPlxuICAgICAgICA8L2Rpdj5cbiAgICAgIH1cbiAgICB9XG4gIDwvZGl2PlxuPC9kaXY+XG5cbjxtYXQtbWVudSAjbWVudT1cIm1hdE1lbnVcIj5cbiAgQGZvciAoY3VsdHVyZSBvZiB0aGlzLmN1bHR1cmVMaXN0OyB0cmFjayBjdWx0dXJlKSB7XG4gICAgPGRpdj5cbiAgICAgIDxkaXYgY2xhc3M9XCJmbGV4LXJvdyBnLXNwYWNlLXNtIHAtc3BhY2Utc21cIj5cbiAgICAgICAgQGlmICh0aGlzLmhhc0tleShjdWx0dXJlLm5hbWUpKSB7XG4gICAgICAgICAgPHRhLWZvbnQtaWNvbiBuYW1lPVwiY2hlY2stbGluZVwiIGNsYXNzPVwiY2hlY2tlZFwiPjwvdGEtZm9udC1pY29uPlxuICAgICAgICAgIDx0YS1saW5rIChhY3Rpb24pPVwidGhpcy5yZW1vdmUoY3VsdHVyZS5uYW1lKVwiPnt7IGN1bHR1cmUubmFtZSB9fTwvdGEtbGluaz5cbiAgICAgICAgfSBAZWxzZSB7XG4gICAgICAgICAgPHRhLWZvbnQtaWNvbiBuYW1lPVwiY2hlY2stbGluZVwiPiA8L3RhLWZvbnQtaWNvbj5cbiAgICAgICAgICA8dGEtbGluayAoYWN0aW9uKT1cInRoaXMuYWRkKGN1bHR1cmUubmFtZSlcIj57eyBjdWx0dXJlLm5hbWUgfX08L3RhLWxpbms+XG4gICAgICAgIH1cbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuICB9XG48L21hdC1tZW51PlxuIl19