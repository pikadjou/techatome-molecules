import { NgIf, NgFor, NgClass, NgTemplateOutlet } from "@angular/common";
import { FontIconComponent } from "@ta/icons";
import { Component, Input } from "@angular/core";
import { MatMenuModule } from "@angular/material/menu";
import { Menu, MenuBase, ToggleNavigationComponent } from "@ta/menu";
import { TranslatePipe } from "@ta/translation";
import { TitleComponent, LinkComponent, ButtonComponent } from "@ta/ui";
import { TaBaseComponent, Culture, extractEnum } from "@ta/utils";
import * as i0 from "@angular/core";
import * as i1 from "@angular/material/menu";
export class InputTranslationComponent extends TaBaseComponent {
    constructor() {
        super();
        this.cultureList = extractEnum(Culture, true);
        this.cultureMenu = null;
        this.currentCulture = Culture[Culture.FR_BE];
    }
    ngOnInit() {
        this._registerSubscription(this.input.listChanged$.subscribe({
            next: () => this._renderMenu(),
        }));
        this._renderMenu();
    }
    changeSelection(culture) {
        this.currentCulture = culture;
    }
    add(culture) {
        this.input.add(culture);
        this.changeSelection(culture);
    }
    remove(culture) {
        this.input.remove(culture);
    }
    hasKey(culture) {
        return this.getKeys().includes(culture);
    }
    getKeys() {
        return Object.keys(this.input.inputsGroup);
    }
    getInputs(culture) {
        return this.input.inputsGroup[culture];
    }
    trackByFn(_, key) {
        return key;
    }
    trackInputByFn(_, input) {
        return input.key;
    }
    _renderMenu() {
        this.cultureMenu = new Menu({
            elements: this.getKeys().map((cul) => new MenuBase({
                key: cul,
                label: cul,
                order: 1,
                defaultOpen: this.currentCulture === cul,
                callback: () => this.changeSelection(cul),
            })),
            direction: "horizontal",
        });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.14", ngImport: i0, type: InputTranslationComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "18.2.14", type: InputTranslationComponent, isStandalone: true, selector: "ta-input-translation", inputs: { input: "input", inputsTemplate: "inputsTemplate" }, usesInheritance: true, ngImport: i0, template: "<div class=\"translation-container\">\n  @if (this.input.label) {\n  <ta-title [level]=\"3\" [isBold]=\"true\">{{\n    this.input.label | translate\n  }}</ta-title>\n  }\n  <div class=\"flex-row align-center g-space-md\">\n    @if (this.cultureMenu) {\n    <ta-toggle-navigation\n      [menu]=\"this.cultureMenu\"\n      container=\"tab\"\n    ></ta-toggle-navigation>\n    }\n    <ta-button\n      size=\"small\"\n      [matMenuTriggerFor]=\"menu\"\n      [stopPropagationActivation]=\"false\"\n      >+</ta-button\n    >\n  </div>\n\n  <div class=\"pt-space-md\">\n    @for (input of this.getInputs(this.currentCulture); track input) { @if\n    (input) {\n    <div [ngClass]=\"input.class\">\n      <ng-container\n        [ngTemplateOutlet]=\"this.inputsTemplate\"\n        [ngTemplateOutletContext]=\"{\n              input: input,\n            }\"\n      >\n      </ng-container>\n    </div>\n    } }\n  </div>\n</div>\n\n<mat-menu #menu=\"matMenu\">\n  @for (culture of this.cultureList; track culture) {\n  <div>\n    <div class=\"flex-row g-space-sm p-space-sm\">\n      @if (this.hasKey(culture.name)) {\n      <ta-font-icon name=\"check-line\" class=\"checked\"></ta-font-icon>\n      <ta-link (action)=\"this.remove(culture.name)\">{{ culture.name }}</ta-link>\n      } @else {\n      <ta-font-icon name=\"check-line\"> </ta-font-icon>\n      <ta-link (action)=\"this.add(culture.name)\">{{ culture.name }}</ta-link>\n      }\n    </div>\n  </div>\n  }\n</mat-menu>\n", styles: [".checked{color:var(--ta-semantic-token-success)}.translation-container{padding:var(--ta-space-md);border-radius:var(--ta-radius-rounded);border:1px solid var(--ta-border-secondary)}\n"], dependencies: [{ kind: "directive", type: NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }, { kind: "component", type: FontIconComponent, selector: "ta-font-icon", inputs: ["name", "type"] }, { kind: "ngmodule", type: MatMenuModule }, { kind: "component", type: i1.MatMenu, selector: "mat-menu", inputs: ["backdropClass", "aria-label", "aria-labelledby", "aria-describedby", "xPosition", "yPosition", "overlapTrigger", "hasBackdrop", "class", "classList"], outputs: ["closed", "close"], exportAs: ["matMenu"] }, { kind: "directive", type: i1.MatMenuTrigger, selector: "[mat-menu-trigger-for], [matMenuTriggerFor]", inputs: ["mat-menu-trigger-for", "matMenuTriggerFor", "matMenuTriggerData", "matMenuTriggerRestoreFocus"], outputs: ["menuOpened", "onMenuOpen", "menuClosed", "onMenuClose"], exportAs: ["matMenuTrigger"] }, { kind: "component", type: ToggleNavigationComponent, selector: "ta-toggle-navigation", inputs: ["menu", "container"] }, { kind: "component", type: TitleComponent, selector: "ta-title", inputs: ["level", "isTheme", "isBold", "icon"] }, { kind: "component", type: LinkComponent, selector: "ta-link", inputs: ["state", "underline", "bold", "size", "icon"], outputs: ["action"] }, { kind: "component", type: ButtonComponent, selector: "ta-button", inputs: ["state", "type", "size", "icon", "options", "stopPropagationActivation"], outputs: ["action"] }, { kind: "pipe", type: TranslatePipe, name: "translate" }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.14", ngImport: i0, type: InputTranslationComponent, decorators: [{
            type: Component,
            args: [{ selector: "ta-input-translation", standalone: true, imports: [
                        NgIf,
                        NgFor,
                        NgClass,
                        NgTemplateOutlet,
                        FontIconComponent,
                        MatMenuModule,
                        ToggleNavigationComponent,
                        TitleComponent,
                        LinkComponent,
                        ButtonComponent,
                        TranslatePipe,
                    ], template: "<div class=\"translation-container\">\n  @if (this.input.label) {\n  <ta-title [level]=\"3\" [isBold]=\"true\">{{\n    this.input.label | translate\n  }}</ta-title>\n  }\n  <div class=\"flex-row align-center g-space-md\">\n    @if (this.cultureMenu) {\n    <ta-toggle-navigation\n      [menu]=\"this.cultureMenu\"\n      container=\"tab\"\n    ></ta-toggle-navigation>\n    }\n    <ta-button\n      size=\"small\"\n      [matMenuTriggerFor]=\"menu\"\n      [stopPropagationActivation]=\"false\"\n      >+</ta-button\n    >\n  </div>\n\n  <div class=\"pt-space-md\">\n    @for (input of this.getInputs(this.currentCulture); track input) { @if\n    (input) {\n    <div [ngClass]=\"input.class\">\n      <ng-container\n        [ngTemplateOutlet]=\"this.inputsTemplate\"\n        [ngTemplateOutletContext]=\"{\n              input: input,\n            }\"\n      >\n      </ng-container>\n    </div>\n    } }\n  </div>\n</div>\n\n<mat-menu #menu=\"matMenu\">\n  @for (culture of this.cultureList; track culture) {\n  <div>\n    <div class=\"flex-row g-space-sm p-space-sm\">\n      @if (this.hasKey(culture.name)) {\n      <ta-font-icon name=\"check-line\" class=\"checked\"></ta-font-icon>\n      <ta-link (action)=\"this.remove(culture.name)\">{{ culture.name }}</ta-link>\n      } @else {\n      <ta-font-icon name=\"check-line\"> </ta-font-icon>\n      <ta-link (action)=\"this.add(culture.name)\">{{ culture.name }}</ta-link>\n      }\n    </div>\n  </div>\n  }\n</mat-menu>\n", styles: [".checked{color:var(--ta-semantic-token-success)}.translation-container{padding:var(--ta-space-md);border-radius:var(--ta-radius-rounded);border:1px solid var(--ta-border-secondary)}\n"] }]
        }], ctorParameters: () => [], propDecorators: { input: [{
                type: Input
            }], inputsTemplate: [{
                type: Input
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJhbnNsYXRpb24uY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vc3JjL2xpYi9jb21wb25lbnRzL2lucHV0L3RyYW5zbGF0aW9uL3RyYW5zbGF0aW9uLmNvbXBvbmVudC50cyIsIi4uLy4uLy4uLy4uLy4uLy4uL3NyYy9saWIvY29tcG9uZW50cy9pbnB1dC90cmFuc2xhdGlvbi90cmFuc2xhdGlvbi5jb21wb25lbnQuaHRtbCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsSUFBSSxFQUFFLEtBQUssRUFBRSxPQUFPLEVBQUUsZ0JBQWdCLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQztBQUN6RSxPQUFPLEVBQUUsaUJBQWlCLEVBQUUsTUFBTSxXQUFXLENBQUM7QUFDOUMsT0FBTyxFQUFFLFNBQVMsRUFBRSxLQUFLLEVBQXVCLE1BQU0sZUFBZSxDQUFDO0FBQ3RFLE9BQU8sRUFBRSxhQUFhLEVBQUUsTUFBTSx3QkFBd0IsQ0FBQztBQUd2RCxPQUFPLEVBQUUsSUFBSSxFQUFFLFFBQVEsRUFBRSx5QkFBeUIsRUFBRSxNQUFNLFVBQVUsQ0FBQztBQUNyRSxPQUFPLEVBQUUsYUFBYSxFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFDaEQsT0FBTyxFQUFFLGNBQWMsRUFBRSxhQUFhLEVBQUUsZUFBZSxFQUFFLE1BQU0sUUFBUSxDQUFDO0FBQ3hFLE9BQU8sRUFBRSxlQUFlLEVBQUUsT0FBTyxFQUFFLFdBQVcsRUFBRSxNQUFNLFdBQVcsQ0FBQzs7O0FBcUJsRSxNQUFNLE9BQU8seUJBQ1gsU0FBUSxlQUFlO0lBYXZCO1FBQ0UsS0FBSyxFQUFFLENBQUM7UUFOSCxnQkFBVyxHQUFHLFdBQVcsQ0FBQyxPQUFPLEVBQUUsSUFBSSxDQUFDLENBQUM7UUFDekMsZ0JBQVcsR0FBZ0IsSUFBSSxDQUFDO1FBRWhDLG1CQUFjLEdBQVcsT0FBTyxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUl2RCxDQUFDO0lBRUQsUUFBUTtRQUNOLElBQUksQ0FBQyxxQkFBcUIsQ0FDeEIsSUFBSSxDQUFDLEtBQUssQ0FBQyxZQUFZLENBQUMsU0FBUyxDQUFDO1lBQ2hDLElBQUksRUFBRSxHQUFHLEVBQUUsQ0FBQyxJQUFJLENBQUMsV0FBVyxFQUFFO1NBQy9CLENBQUMsQ0FDSCxDQUFDO1FBQ0YsSUFBSSxDQUFDLFdBQVcsRUFBRSxDQUFDO0lBQ3JCLENBQUM7SUFFTSxlQUFlLENBQUMsT0FBZTtRQUNwQyxJQUFJLENBQUMsY0FBYyxHQUFHLE9BQU8sQ0FBQztJQUNoQyxDQUFDO0lBRU0sR0FBRyxDQUFDLE9BQWU7UUFDeEIsSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFDLENBQUM7UUFDeEIsSUFBSSxDQUFDLGVBQWUsQ0FBQyxPQUFPLENBQUMsQ0FBQztJQUNoQyxDQUFDO0lBRU0sTUFBTSxDQUFDLE9BQWU7UUFDM0IsSUFBSSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLENBQUM7SUFDN0IsQ0FBQztJQUVNLE1BQU0sQ0FBQyxPQUFlO1FBQzNCLE9BQU8sSUFBSSxDQUFDLE9BQU8sRUFBRSxDQUFDLFFBQVEsQ0FBQyxPQUFPLENBQUMsQ0FBQztJQUMxQyxDQUFDO0lBQ00sT0FBTztRQUNaLE9BQU8sTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLFdBQVcsQ0FBQyxDQUFDO0lBQzdDLENBQUM7SUFFTSxTQUFTLENBQUMsT0FBZTtRQUM5QixPQUFPLElBQUksQ0FBQyxLQUFLLENBQUMsV0FBVyxDQUFDLE9BQU8sQ0FBQyxDQUFDO0lBQ3pDLENBQUM7SUFFTSxTQUFTLENBQUMsQ0FBUyxFQUFFLEdBQVc7UUFDckMsT0FBTyxHQUFHLENBQUM7SUFDYixDQUFDO0lBRU0sY0FBYyxDQUFDLENBQVMsRUFBRSxLQUFxQjtRQUNwRCxPQUFPLEtBQUssQ0FBQyxHQUFHLENBQUM7SUFDbkIsQ0FBQztJQUVPLFdBQVc7UUFDakIsSUFBSSxDQUFDLFdBQVcsR0FBRyxJQUFJLElBQUksQ0FBQztZQUMxQixRQUFRLEVBQUUsSUFBSSxDQUFDLE9BQU8sRUFBRSxDQUFDLEdBQUcsQ0FDMUIsQ0FBQyxHQUFHLEVBQUUsRUFBRSxDQUNOLElBQUksUUFBUSxDQUFDO2dCQUNYLEdBQUcsRUFBRSxHQUFHO2dCQUNSLEtBQUssRUFBRSxHQUFHO2dCQUNWLEtBQUssRUFBRSxDQUFDO2dCQUNSLFdBQVcsRUFBRSxJQUFJLENBQUMsY0FBYyxLQUFLLEdBQUc7Z0JBQ3hDLFFBQVEsRUFBRSxHQUFHLEVBQUUsQ0FBQyxJQUFJLENBQUMsZUFBZSxDQUFDLEdBQUcsQ0FBQzthQUMxQyxDQUFDLENBQ0w7WUFDRCxTQUFTLEVBQUUsWUFBWTtTQUN4QixDQUFDLENBQUM7SUFDTCxDQUFDOytHQXpFVSx5QkFBeUI7bUdBQXpCLHlCQUF5QixxS0M5QnRDLHU4Q0FvREEsaVBEakNJLE9BQU8sb0ZBQ1AsZ0JBQWdCLG9KQUNoQixpQkFBaUIsa0ZBQ2pCLGFBQWEsMG1CQUNiLHlCQUF5QixnR0FDekIsY0FBYyxxR0FDZCxhQUFhLGlJQUNiLGVBQWUseUpBQ2YsYUFBYTs7NEZBR0oseUJBQXlCO2tCQW5CckMsU0FBUzsrQkFDRSxzQkFBc0IsY0FHcEIsSUFBSSxXQUNQO3dCQUNQLElBQUk7d0JBQ0osS0FBSzt3QkFDTCxPQUFPO3dCQUNQLGdCQUFnQjt3QkFDaEIsaUJBQWlCO3dCQUNqQixhQUFhO3dCQUNiLHlCQUF5Qjt3QkFDekIsY0FBYzt3QkFDZCxhQUFhO3dCQUNiLGVBQWU7d0JBQ2YsYUFBYTtxQkFDZDt3REFPRCxLQUFLO3NCQURKLEtBQUs7Z0JBR04sY0FBYztzQkFEYixLQUFLIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTmdJZiwgTmdGb3IsIE5nQ2xhc3MsIE5nVGVtcGxhdGVPdXRsZXQgfSBmcm9tIFwiQGFuZ3VsYXIvY29tbW9uXCI7XG5pbXBvcnQgeyBGb250SWNvbkNvbXBvbmVudCB9IGZyb20gXCJAdGEvaWNvbnNcIjtcbmltcG9ydCB7IENvbXBvbmVudCwgSW5wdXQsIE9uSW5pdCwgVGVtcGxhdGVSZWYgfSBmcm9tIFwiQGFuZ3VsYXIvY29yZVwiO1xuaW1wb3J0IHsgTWF0TWVudU1vZHVsZSB9IGZyb20gXCJAYW5ndWxhci9tYXRlcmlhbC9tZW51XCI7XG5cbmltcG9ydCB7IElucHV0QmFzZSwgSW5wdXRUcmFuc2xhdGlvbiB9IGZyb20gXCJAdGEvZm9ybS1tb2RlbFwiO1xuaW1wb3J0IHsgTWVudSwgTWVudUJhc2UsIFRvZ2dsZU5hdmlnYXRpb25Db21wb25lbnQgfSBmcm9tIFwiQHRhL21lbnVcIjtcbmltcG9ydCB7IFRyYW5zbGF0ZVBpcGUgfSBmcm9tIFwiQHRhL3RyYW5zbGF0aW9uXCI7XG5pbXBvcnQgeyBUaXRsZUNvbXBvbmVudCwgTGlua0NvbXBvbmVudCwgQnV0dG9uQ29tcG9uZW50IH0gZnJvbSBcIkB0YS91aVwiO1xuaW1wb3J0IHsgVGFCYXNlQ29tcG9uZW50LCBDdWx0dXJlLCBleHRyYWN0RW51bSB9IGZyb20gXCJAdGEvdXRpbHNcIjtcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiBcInRhLWlucHV0LXRyYW5zbGF0aW9uXCIsXG4gIHRlbXBsYXRlVXJsOiBcIi4vdHJhbnNsYXRpb24uY29tcG9uZW50Lmh0bWxcIixcbiAgc3R5bGVVcmxzOiBbXCIuL3RyYW5zbGF0aW9uLmNvbXBvbmVudC5zY3NzXCJdLFxuICBzdGFuZGFsb25lOiB0cnVlLFxuICBpbXBvcnRzOiBbXG4gICAgTmdJZixcbiAgICBOZ0ZvcixcbiAgICBOZ0NsYXNzLFxuICAgIE5nVGVtcGxhdGVPdXRsZXQsXG4gICAgRm9udEljb25Db21wb25lbnQsXG4gICAgTWF0TWVudU1vZHVsZSxcbiAgICBUb2dnbGVOYXZpZ2F0aW9uQ29tcG9uZW50LFxuICAgIFRpdGxlQ29tcG9uZW50LFxuICAgIExpbmtDb21wb25lbnQsXG4gICAgQnV0dG9uQ29tcG9uZW50LFxuICAgIFRyYW5zbGF0ZVBpcGUsXG4gIF0sXG59KVxuZXhwb3J0IGNsYXNzIElucHV0VHJhbnNsYXRpb25Db21wb25lbnRcbiAgZXh0ZW5kcyBUYUJhc2VDb21wb25lbnRcbiAgaW1wbGVtZW50cyBPbkluaXRcbntcbiAgQElucHV0KClcbiAgaW5wdXQhOiBJbnB1dFRyYW5zbGF0aW9uO1xuICBASW5wdXQoKVxuICBpbnB1dHNUZW1wbGF0ZSE6IFRlbXBsYXRlUmVmPGFueT47XG5cbiAgcHVibGljIGN1bHR1cmVMaXN0ID0gZXh0cmFjdEVudW0oQ3VsdHVyZSwgdHJ1ZSk7XG4gIHB1YmxpYyBjdWx0dXJlTWVudTogTWVudSB8IG51bGwgPSBudWxsO1xuXG4gIHB1YmxpYyBjdXJyZW50Q3VsdHVyZTogc3RyaW5nID0gQ3VsdHVyZVtDdWx0dXJlLkZSX0JFXTtcblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuICB9XG5cbiAgbmdPbkluaXQoKSB7XG4gICAgdGhpcy5fcmVnaXN0ZXJTdWJzY3JpcHRpb24oXG4gICAgICB0aGlzLmlucHV0Lmxpc3RDaGFuZ2VkJC5zdWJzY3JpYmUoe1xuICAgICAgICBuZXh0OiAoKSA9PiB0aGlzLl9yZW5kZXJNZW51KCksXG4gICAgICB9KVxuICAgICk7XG4gICAgdGhpcy5fcmVuZGVyTWVudSgpO1xuICB9XG5cbiAgcHVibGljIGNoYW5nZVNlbGVjdGlvbihjdWx0dXJlOiBzdHJpbmcpIHtcbiAgICB0aGlzLmN1cnJlbnRDdWx0dXJlID0gY3VsdHVyZTtcbiAgfVxuXG4gIHB1YmxpYyBhZGQoY3VsdHVyZTogc3RyaW5nKSB7XG4gICAgdGhpcy5pbnB1dC5hZGQoY3VsdHVyZSk7XG4gICAgdGhpcy5jaGFuZ2VTZWxlY3Rpb24oY3VsdHVyZSk7XG4gIH1cblxuICBwdWJsaWMgcmVtb3ZlKGN1bHR1cmU6IHN0cmluZykge1xuICAgIHRoaXMuaW5wdXQucmVtb3ZlKGN1bHR1cmUpO1xuICB9XG5cbiAgcHVibGljIGhhc0tleShjdWx0dXJlOiBzdHJpbmcpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRLZXlzKCkuaW5jbHVkZXMoY3VsdHVyZSk7XG4gIH1cbiAgcHVibGljIGdldEtleXMoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuaW5wdXQuaW5wdXRzR3JvdXApO1xuICB9XG5cbiAgcHVibGljIGdldElucHV0cyhjdWx0dXJlOiBzdHJpbmcpIHtcbiAgICByZXR1cm4gdGhpcy5pbnB1dC5pbnB1dHNHcm91cFtjdWx0dXJlXTtcbiAgfVxuXG4gIHB1YmxpYyB0cmFja0J5Rm4oXzogbnVtYmVyLCBrZXk6IHN0cmluZykge1xuICAgIHJldHVybiBrZXk7XG4gIH1cblxuICBwdWJsaWMgdHJhY2tJbnB1dEJ5Rm4oXzogbnVtYmVyLCBpbnB1dDogSW5wdXRCYXNlPGFueT4pIHtcbiAgICByZXR1cm4gaW5wdXQua2V5O1xuICB9XG5cbiAgcHJpdmF0ZSBfcmVuZGVyTWVudSgpIHtcbiAgICB0aGlzLmN1bHR1cmVNZW51ID0gbmV3IE1lbnUoe1xuICAgICAgZWxlbWVudHM6IHRoaXMuZ2V0S2V5cygpLm1hcChcbiAgICAgICAgKGN1bCkgPT5cbiAgICAgICAgICBuZXcgTWVudUJhc2Uoe1xuICAgICAgICAgICAga2V5OiBjdWwsXG4gICAgICAgICAgICBsYWJlbDogY3VsLFxuICAgICAgICAgICAgb3JkZXI6IDEsXG4gICAgICAgICAgICBkZWZhdWx0T3BlbjogdGhpcy5jdXJyZW50Q3VsdHVyZSA9PT0gY3VsLFxuICAgICAgICAgICAgY2FsbGJhY2s6ICgpID0+IHRoaXMuY2hhbmdlU2VsZWN0aW9uKGN1bCksXG4gICAgICAgICAgfSlcbiAgICAgICksXG4gICAgICBkaXJlY3Rpb246IFwiaG9yaXpvbnRhbFwiLFxuICAgIH0pO1xuICB9XG59XG4iLCI8ZGl2IGNsYXNzPVwidHJhbnNsYXRpb24tY29udGFpbmVyXCI+XG4gIEBpZiAodGhpcy5pbnB1dC5sYWJlbCkge1xuICA8dGEtdGl0bGUgW2xldmVsXT1cIjNcIiBbaXNCb2xkXT1cInRydWVcIj57e1xuICAgIHRoaXMuaW5wdXQubGFiZWwgfCB0cmFuc2xhdGVcbiAgfX08L3RhLXRpdGxlPlxuICB9XG4gIDxkaXYgY2xhc3M9XCJmbGV4LXJvdyBhbGlnbi1jZW50ZXIgZy1zcGFjZS1tZFwiPlxuICAgIEBpZiAodGhpcy5jdWx0dXJlTWVudSkge1xuICAgIDx0YS10b2dnbGUtbmF2aWdhdGlvblxuICAgICAgW21lbnVdPVwidGhpcy5jdWx0dXJlTWVudVwiXG4gICAgICBjb250YWluZXI9XCJ0YWJcIlxuICAgID48L3RhLXRvZ2dsZS1uYXZpZ2F0aW9uPlxuICAgIH1cbiAgICA8dGEtYnV0dG9uXG4gICAgICBzaXplPVwic21hbGxcIlxuICAgICAgW21hdE1lbnVUcmlnZ2VyRm9yXT1cIm1lbnVcIlxuICAgICAgW3N0b3BQcm9wYWdhdGlvbkFjdGl2YXRpb25dPVwiZmFsc2VcIlxuICAgICAgPis8L3RhLWJ1dHRvblxuICAgID5cbiAgPC9kaXY+XG5cbiAgPGRpdiBjbGFzcz1cInB0LXNwYWNlLW1kXCI+XG4gICAgQGZvciAoaW5wdXQgb2YgdGhpcy5nZXRJbnB1dHModGhpcy5jdXJyZW50Q3VsdHVyZSk7IHRyYWNrIGlucHV0KSB7IEBpZlxuICAgIChpbnB1dCkge1xuICAgIDxkaXYgW25nQ2xhc3NdPVwiaW5wdXQuY2xhc3NcIj5cbiAgICAgIDxuZy1jb250YWluZXJcbiAgICAgICAgW25nVGVtcGxhdGVPdXRsZXRdPVwidGhpcy5pbnB1dHNUZW1wbGF0ZVwiXG4gICAgICAgIFtuZ1RlbXBsYXRlT3V0bGV0Q29udGV4dF09XCJ7XG4gICAgICAgICAgICAgIGlucHV0OiBpbnB1dCxcbiAgICAgICAgICAgIH1cIlxuICAgICAgPlxuICAgICAgPC9uZy1jb250YWluZXI+XG4gICAgPC9kaXY+XG4gICAgfSB9XG4gIDwvZGl2PlxuPC9kaXY+XG5cbjxtYXQtbWVudSAjbWVudT1cIm1hdE1lbnVcIj5cbiAgQGZvciAoY3VsdHVyZSBvZiB0aGlzLmN1bHR1cmVMaXN0OyB0cmFjayBjdWx0dXJlKSB7XG4gIDxkaXY+XG4gICAgPGRpdiBjbGFzcz1cImZsZXgtcm93IGctc3BhY2Utc20gcC1zcGFjZS1zbVwiPlxuICAgICAgQGlmICh0aGlzLmhhc0tleShjdWx0dXJlLm5hbWUpKSB7XG4gICAgICA8dGEtZm9udC1pY29uIG5hbWU9XCJjaGVjay1saW5lXCIgY2xhc3M9XCJjaGVja2VkXCI+PC90YS1mb250LWljb24+XG4gICAgICA8dGEtbGluayAoYWN0aW9uKT1cInRoaXMucmVtb3ZlKGN1bHR1cmUubmFtZSlcIj57eyBjdWx0dXJlLm5hbWUgfX08L3RhLWxpbms+XG4gICAgICB9IEBlbHNlIHtcbiAgICAgIDx0YS1mb250LWljb24gbmFtZT1cImNoZWNrLWxpbmVcIj4gPC90YS1mb250LWljb24+XG4gICAgICA8dGEtbGluayAoYWN0aW9uKT1cInRoaXMuYWRkKGN1bHR1cmUubmFtZSlcIj57eyBjdWx0dXJlLm5hbWUgfX08L3RhLWxpbms+XG4gICAgICB9XG4gICAgPC9kaXY+XG4gIDwvZGl2PlxuICB9XG48L21hdC1tZW51PlxuIl19